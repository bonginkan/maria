/**
 * Active Reporting Service - Main Service
 * Core implementation for systematic Horenso and SOW/TODO management
 */

import { EventEmitter } from 'events';
import * as crypto from 'crypto';
import chalk from 'chalk';
import {
  Task,
  SOW,
  ProgressReport,
  HourensouReport,
  IntentAnalysis,
  TaskDecomposition,
  ProgressMetrics,
  ActiveReportingConfig,
  ServiceState,
  DecisionPoint,
  CollaborativePlan as _CollaborativePlan,
  ProactiveReportTrigger,
} from './types';
import { IntentAnalyzer } from './IntentAnalyzer';
import { SOWGenerator } from './SOWGenerator';
import { TaskDecomposer } from './TaskDecomposer';
import { ProgressTracker } from './ProgressTracker';
import { TaskVisualizer } from './TaskVisualizer';
import { ProactiveReporter } from './ProactiveReporter';
import { CollaborativePlanner } from './CollaborativePlanner';

export class ActiveReportingService extends EventEmitter {
  private static instance: ActiveReportingService;

  private state: ServiceState;
  private intentAnalyzer: IntentAnalyzer;
  private sowGenerator: SOWGenerator;
  private taskDecomposer: TaskDecomposer;
  private progressTracker: ProgressTracker;
  private taskVisualizer: TaskVisualizer;
  private proactiveReporter: ProactiveReporter;
  private collaborativePlanner: CollaborativePlanner;

  private reportingInterval?: NodeJS.Timeout;
  private lastReportTime: Date;
  private isInitialized: boolean = false;

  private constructor() {
    super();

    // Initialize default configuration
    this.state = {
      activeTasks: [],
      completedTasks: [],
      blockedTasks: [],
      pendingDecisions: [],
      reportHistory: [],
      metrics: {
        tasksCompleted: 0,
        tasksTotal: 0,
        progressPercentage: 0,
        timeSpent: 0,
        timeEstimated: 0,
        velocity: 0,
        eta: new Date(),
        confidenceLevel: 0,
      },
      config: this.getDefaultConfig(),
    };

    this.lastReportTime = new Date();

    // Initialize sub-services
    this.intentAnalyzer = new IntentAnalyzer();
    this.sowGenerator = new SOWGenerator();
    this.taskDecomposer = new TaskDecomposer();
    this.progressTracker = new ProgressTracker();
    this.taskVisualizer = new TaskVisualizer();
    this.proactiveReporter = new ProactiveReporter();
    this.collaborativePlanner = new CollaborativePlanner();
  }

  public static getInstance(): ActiveReportingService {
    if (!ActiveReportingService.instance) {
      ActiveReportingService.instance = new ActiveReportingService();
    }
    return ActiveReportingService.instance;
  }

  /**
   * Initialize the service
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) return;

    console.log(chalk.cyan('âœ¨ Initializing Active Reporting Service...'));

    // Initialize sub-services
    await this.intentAnalyzer.initialize();
    await this.sowGenerator.initialize();
    await this.taskDecomposer.initialize();
    await this.progressTracker.initialize();
    await this.proactiveReporter.initialize();
    await this.collaborativePlanner.initialize();

    // Set up automatic reporting
    this.setupAutomaticReporting();

    // Set up event listeners
    this.setupEventListeners();

    this.isInitialized = true;
    console.log(chalk.green('âœ“ Active Reporting Service initialized'));
  }

  /**
   * Process user request with full Horenso workflow
   */
  public async processRequest(request: string, context?: unknown): Promise<SOW> {
    // Step 1: Analyze intent (ç†è§£)
    const intent = await this.analyzeIntent(request, context);

    // Step 2: Generate SOW (è¨ˆç”»)
    const sow = await this.generateSOW(intent, request);

    // Step 3: Get approval (ç›¸è«‡ - Sou)
    const approvedSOW = await this.getApproval(sow);

    // Step 4: Decompose into tasks (æ•´ç†)
    const decomposition = await this.decomposeTasks(approvedSOW);

    // Step 5: Start execution with reporting (å®Ÿè¡Œ + å ±å‘Š)
    await this.startExecution(decomposition);

    return approvedSOW;
  }

  /**
   * Analyze user intent
   */
  private async analyzeIntent(request: string, context?: unknown): Promise<IntentAnalysis> {
    // Report: Starting analysis (Hou)
    await this.reportProgress({
      type: 'hourensou_hou',
      timestamp: new Date(),
      summary: 'è¦æ±‚åˆ†æã‚’é–‹å§‹ã—ã¾ã™',
      completedTasks: [],
      currentTasks: [
        {
          id: crypto.randomUUID(),
          title: 'æ„å›³åˆ†æ',
          description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¦æ±‚ã‚’ç†è§£ã—ã¦ã„ã¾ã™',
          status: 'in_progress',
          priority: 'high',
          estimatedTime: 1,
          assignee: 'ai',
          progress: 50,
          dependencies: [],
          metadata: {
            createdAt: new Date(),
            updatedAt: new Date(),
            autoGenerated: true,
          },
        },
      ],
      upcomingTasks: [],
      blockers: [],
      recommendations: [],
      overallProgress: 0,
      nextSteps: ['æ„å›³åˆ†æå®Œäº†', 'SOWç”Ÿæˆ'],
    });

    return await this.intentAnalyzer.analyze(request, context);
  }

  /**
   * Generate Statement of Work
   */
  private async generateSOW(intent: IntentAnalysis, request: string): Promise<SOW> {
    // Contact: SOW generation started (Ren)
    await this.contactUpdate({
      type: 'hourensou_ren',
      timestamp: new Date(),
      summary: 'SOWï¼ˆä½œæ¥­è¨ˆç”»æ›¸ï¼‰ã‚’ç”Ÿæˆä¸­ã§ã™',
      completedTasks: [],
      currentTasks: [],
      upcomingTasks: [],
      blockers: [],
      recommendations: [],
      overallProgress: 10,
      nextSteps: ['SOWè‰æ¡ˆä½œæˆ', 'ãƒªã‚¹ã‚¯åˆ†æ', 'ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³è¨­å®š'],
    });

    const sow = await this.sowGenerator.generate(intent, request);

    // Visualize the SOW
    const visualization = this.taskVisualizer.visualizeSOW(sow);
    console.log(visualization);

    return sow;
  }

  /**
   * Get approval for SOW (Consultation - Sou)
   */
  private async getApproval(sow: SOW): Promise<SOW> {
    // Consult: Request approval (Sou)
    const decision: DecisionPoint = {
      id: crypto.randomUUID(),
      question: 'ã“ã®SOWã§ä½œæ¥­ã‚’é–‹å§‹ã—ã¦ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ',
      context: `ç›®çš„: ${sow.objective}\nã‚¿ã‚¹ã‚¯æ•°: ${sow.tasks.length}\næ¨å®šæ™‚é–“: ${this.calculateTotalTime(sow.tasks)}æ™‚é–“`,
      options: [
        {
          id: 'approve',
          label: 'æ‰¿èª',
          description: 'ã“ã®ãƒ—ãƒ©ãƒ³ã§ä½œæ¥­ã‚’é–‹å§‹ã—ã¾ã™',
          pros: ['æ˜ç¢ºãªè¨ˆç”»', 'è©³ç´°ãªã‚¿ã‚¹ã‚¯åˆ†è§£'],
          cons: [],
        },
        {
          id: 'modify',
          label: 'ä¿®æ­£',
          description: 'ãƒ—ãƒ©ãƒ³ã‚’ä¿®æ­£ã—ã¾ã™',
          pros: ['è¦ä»¶ã®ç²¾ç·»åŒ–'],
          cons: ['è¿½åŠ æ™‚é–“ãŒå¿…è¦'],
        },
        {
          id: 'reject',
          label: 'å´ä¸‹',
          description: 'åˆ¥ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’æ¤œè¨ã—ã¾ã™',
          pros: ['æ ¹æœ¬çš„ãªè¦‹ç›´ã—'],
          cons: ['è¨ˆç”»ã®å†ä½œæˆãŒå¿…è¦'],
        },
      ],
      recommendation: 'approve',
      impact: 'high',
    };

    await this.consultUser({
      type: 'hourensou_sou',
      timestamp: new Date(),
      summary: 'SOWæ‰¿èªãŒå¿…è¦ã§ã™',
      completedTasks: [],
      currentTasks: [],
      upcomingTasks: sow.tasks,
      blockers: [],
      recommendations: ['ææ¡ˆã•ã‚ŒãŸSOWã¯è¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã™'],
      overallProgress: 15,
      requiresUserInput: [decision],
      nextSteps: ['æ‰¿èªå¾…ã¡', 'ã‚¿ã‚¹ã‚¯å®Ÿè¡Œæº–å‚™'],
    });

    // For now, auto-approve if configured
    if (this.state.config.autoGenerateSOW && !this.state.config.requireSOWApproval) {
      sow.approvalStatus = 'approved';
      console.log(chalk.green('âœ“ SOWè‡ªå‹•æ‰¿èªã•ã‚Œã¾ã—ãŸ'));
    } else {
      // In real implementation, wait for user input
      sow.approvalStatus = 'approved';
    }

    return sow;
  }

  /**
   * Decompose SOW into executable tasks
   */
  private async decomposeTasks(sow: SOW): Promise<TaskDecomposition> {
    const decomposition = await this.taskDecomposer.decompose(sow);

    // Update state with new tasks
    this.state.activeTasks = decomposition.subtasks;
    this.state.metrics.tasksTotal = decomposition.subtasks.length;
    this.state.metrics.timeEstimated = decomposition.estimatedTotalTime;

    // Visualize task breakdown
    const visualization = this.taskVisualizer.visualizeTasks(decomposition.subtasks);
    console.log(visualization);

    return decomposition;
  }

  /**
   * Start task execution with reporting
   */
  private async startExecution(decomposition: TaskDecomposition): Promise<void> {
    this.state.currentSOW = await this.sowGenerator.createFromDecomposition(decomposition);

    // Report: Execution started (Hou)
    await this.reportProgress({
      type: 'hourensou_hou',
      timestamp: new Date(),
      summary: 'ä½œæ¥­ã‚’é–‹å§‹ã—ã¾ã—ãŸ',
      completedTasks: [],
      currentTasks: decomposition.subtasks.filter((t) => t.status === 'in_progress'),
      upcomingTasks: decomposition.subtasks.filter((t) => t.status === 'pending'),
      blockers: [],
      recommendations:
        decomposition.parallelizableGroups.length > 0 ? ['ä¸¦åˆ—å®Ÿè¡Œå¯èƒ½ãªã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã™'] : [],
      overallProgress: 20,
      visualRepresentation: this.taskVisualizer.visualizeProgress(this.state.metrics),
      nextSteps: decomposition.criticalPath
        .slice(0, 3)
        .map((id) => {
          const task = decomposition.subtasks.find((t) => t.id === id);
          return task ? task.title : '';
        })
        .filter(Boolean),
    });

    // Start progress tracking
    await this.progressTracker.startTracking(this.state.activeTasks);
  }

  /**
   * Report progress (Hou - å ±å‘Š)
   */
  private async reportProgress(report: ProgressReport): Promise<void> {
    console.log(chalk.blue('\nğŸ“Š é€²æ—å ±å‘Š (Hou):'));
    console.log(chalk.gray('â”€'.repeat(50)));
    console.log(report.summary);

    if (report.visualRepresentation) {
      console.log(report.visualRepresentation);
    }

    this.state.reportHistory.push(report);
    this.emit('progress:reported', report);
  }

  /**
   * Send update (Ren - é€£çµ¡)
   */
  private async contactUpdate(report: ProgressReport): Promise<void> {
    console.log(chalk.yellow('\nğŸ“¢ é€£çµ¡äº‹é … (Ren):'));
    console.log(chalk.gray('â”€'.repeat(50)));
    console.log(report.summary);

    if (report.nextSteps && report.nextSteps.length > 0) {
      console.log(chalk.gray('\næ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:'));
      report.nextSteps.forEach((step, i) => {
        console.log(chalk.gray(`  ${i + 1}. ${step}`));
      });
    }

    this.state.reportHistory.push(report);
    this.emit('update:sent', report);
  }

  /**
   * Consult user (Sou - ç›¸è«‡)
   */
  private async consultUser(report: ProgressReport): Promise<void> {
    console.log(chalk.magenta('\nğŸ’­ ç›¸è«‡äº‹é … (Sou):'));
    console.log(chalk.gray('â”€'.repeat(50)));
    console.log(report.summary);

    if (report.requiresUserInput && report.requiresUserInput.length > 0) {
      for (const decision of report.requiresUserInput) {
        console.log(chalk.cyan(`\nè³ªå•: ${decision.question}`));
        console.log(chalk.gray(`ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ: ${decision.context}`));

        if (decision.options) {
          console.log(chalk.gray('\nã‚ªãƒ—ã‚·ãƒ§ãƒ³:'));
          decision.options.forEach((option) => {
            console.log(chalk.white(`  â€¢ ${option.label}: ${option.description}`));
          });
        }

        if (decision.recommendation) {
          console.log(chalk.green(`\næ¨å¥¨: ${decision.recommendation}`));
        }
      }
    }

    this.state.reportHistory.push(report);
    this.emit('consultation:requested', report);
  }

  /**
   * Update task status
   */
  public async updateTaskStatus(
    taskId: string,
    status: Task['status'],
    progress?: number,
  ): Promise<void> {
    const task = this.state.activeTasks.find((t) => t.id === taskId);
    if (!task) return;

    const oldStatus = task.status;
    task.status = status;
    if (progress !== undefined) {
      task.progress = progress;
    }

    // Handle status transitions
    if (status === 'completed' && oldStatus !== 'completed') {
      this.state.completedTasks.push(task);
      this.state.activeTasks = this.state.activeTasks.filter((t) => t.id !== taskId);
      this.state.metrics.tasksCompleted++;

      // Report completion (Hou)
      await this.reportProgress({
        type: 'hourensou_hou',
        timestamp: new Date(),
        summary: `ã‚¿ã‚¹ã‚¯å®Œäº†: ${task.title}`,
        completedTasks: [task],
        currentTasks: this.state.activeTasks.filter((t) => t.status === 'in_progress'),
        upcomingTasks: this.state.activeTasks.filter((t) => t.status === 'pending'),
        blockers: [],
        recommendations: [],
        overallProgress: this.calculateOverallProgress(),
        nextSteps: this.getNextSteps(),
      });
    } else if (status === 'blocked' && oldStatus !== 'blocked') {
      this.state.blockedTasks.push(task);

      // Consult on blocker (Sou)
      await this.consultUser({
        type: 'hourensou_sou',
        timestamp: new Date(),
        summary: `ã‚¿ã‚¹ã‚¯ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ: ${task.title}`,
        completedTasks: [],
        currentTasks: [],
        upcomingTasks: [],
        blockers: [
          {
            id: crypto.randomUUID(),
            taskId: task.id,
            description: `${task.title} ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™`,
            severity: 'high',
            identifiedAt: new Date(),
            impact: 'å¾Œç¶šã‚¿ã‚¹ã‚¯ã®é…å»¶',
          },
        ],
        recommendations: ['ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ã®è§£æ¶ˆãŒå¿…è¦ã§ã™'],
        overallProgress: this.calculateOverallProgress(),
        requiresUserInput: [
          {
            id: crypto.randomUUID(),
            question: 'ã©ã®ã‚ˆã†ã«å¯¾å‡¦ã—ã¾ã™ã‹ï¼Ÿ',
            context: `ã‚¿ã‚¹ã‚¯: ${task.title}`,
            options: [
              {
                id: 'wait',
                label: 'å¾…æ©Ÿ',
                description: 'ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ãŒè§£æ¶ˆã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ',
                pros: ['ä¾å­˜é–¢ä¿‚ã‚’ç¶­æŒ'],
                cons: ['é€²æ—ã®åœæ»'],
              },
              {
                id: 'skip',
                label: 'ã‚¹ã‚­ãƒƒãƒ—',
                description: 'ä»–ã®ã‚¿ã‚¹ã‚¯ã‚’å…ˆã«å®Ÿè¡Œ',
                pros: ['é€²æ—ã‚’ç¶™ç¶š'],
                cons: ['ä¾å­˜é–¢ä¿‚ã®å´©ã‚Œ'],
              },
              {
                id: 'resolve',
                label: 'è§£æ±º',
                description: 'ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ã‚’å³åº§ã«è§£æ±º',
                pros: ['å•é¡Œã®æ ¹æœ¬è§£æ±º'],
                cons: ['è¿½åŠ æ™‚é–“ãŒå¿…è¦'],
              },
            ],
            impact: 'high',
          },
        ],
        nextSteps: ['ãƒ–ãƒ­ãƒƒã‚«ãƒ¼è§£æ¶ˆ', 'ä»£æ›¿ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ'],
      });
    }

    // Update metrics
    this.updateMetrics();
  }

  /**
   * Setup automatic reporting intervals
   */
  private setupAutomaticReporting(): void {
    const config = this.state.config.hourensouFrequency;

    // Regular progress reports (Hou)
    this.reportingInterval = setInterval(
      async () => {
        if (this.state.activeTasks.length > 0) {
          await this.generateHourensouReport();
        }
      },
      config.hou * 60 * 1000,
    );
  }

  /**
   * Generate comprehensive Hourensou report
   */
  private async generateHourensouReport(): Promise<void> {
    const report: HourensouReport = {
      hou: [
        {
          type: 'progress',
          title: 'é€²æ—çŠ¶æ³',
          details: `å®Œäº†: ${this.state.metrics.tasksCompleted}/${this.state.metrics.tasksTotal} ã‚¿ã‚¹ã‚¯`,
          impact: `é€²æ—ç‡: ${this.state.metrics.progressPercentage}%`,
        },
      ],
      ren: [
        {
          type: 'update',
          title: 'ç¾åœ¨ã®ä½œæ¥­',
          message:
            this.state.activeTasks
              .filter((t) => t.status === 'in_progress')
              .map((t) => t.title)
              .join(', ') || 'ãªã—',
          urgency: 'normal',
        },
      ],
      sou:
        this.state.blockedTasks.length > 0
          ? [
              {
                type: 'technical',
                question: 'ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã®å¯¾å‡¦æ–¹æ³•',
                context: `${this.state.blockedTasks.length}å€‹ã®ã‚¿ã‚¹ã‚¯ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™`,
              },
            ]
          : [],
      timestamp: new Date(),
      context: this.state.currentSOW?.title || 'Active Reporting',
    };

    this.state.lastHourensou = report;

    // Display the report
    const visualization = this.taskVisualizer.visualizeHourensou(report);
    console.log(visualization);

    this.emit('hourensou:generated', report);
  }

  /**
   * Setup event listeners
   */
  private setupEventListeners(): void {
    // Listen to progress tracker events
    this.progressTracker.on('task:started', (task: Task) => {
      this.updateTaskStatus(task.id, 'in_progress', 0);
    });

    this.progressTracker.on('task:progressed', (task: Task, progress: number) => {
      this.updateTaskStatus(task.id, 'in_progress', progress);
    });

    this.progressTracker.on('task:completed', (task: Task) => {
      this.updateTaskStatus(task.id, 'completed', 100);
    });

    this.progressTracker.on('task:blocked', (task: Task) => {
      this.updateTaskStatus(task.id, 'blocked');
    });

    // Listen to proactive reporter events
    this.proactiveReporter.on('trigger:activated', (trigger: ProactiveReportTrigger) => {
      this.handleProactiveTrigger(trigger);
    });
  }

  /**
   * Handle proactive reporting trigger
   */
  private async handleProactiveTrigger(trigger: ProactiveReportTrigger): Promise<void> {
    switch (trigger.type) {
      case 'milestone':
        await this.reportProgress({
          type: 'milestone',
          timestamp: new Date(),
          summary: 'ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³é”æˆï¼',
          completedTasks: this.state.completedTasks.slice(-5),
          currentTasks: this.state.activeTasks.filter((t) => t.status === 'in_progress'),
          upcomingTasks: this.state.activeTasks.filter((t) => t.status === 'pending').slice(0, 5),
          blockers: [],
          recommendations: [],
          overallProgress: this.calculateOverallProgress(),
          nextSteps: this.getNextSteps(),
        });
        break;

      case 'blocker':
        await this.consultUser({
          type: 'blocker',
          timestamp: new Date(),
          summary: 'ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ',
          completedTasks: [],
          currentTasks: [],
          upcomingTasks: [],
          blockers: this.state.blockedTasks.map((task) => ({
            id: crypto.randomUUID(),
            taskId: task.id,
            description: `${task.title} is blocked`,
            severity: 'high',
            identifiedAt: new Date(),
            impact: 'Progress halted',
          })),
          recommendations: ['Immediate attention required'],
          overallProgress: this.calculateOverallProgress(),
          nextSteps: ['Resolve blockers', 'Find alternative paths'],
        });
        break;

      case 'hourensou':
        await this.generateHourensouReport();
        break;
    }
  }

  /**
   * Calculate overall progress
   */
  private calculateOverallProgress(): number {
    if (this.state.metrics.tasksTotal === 0) return 0;
    return Math.round((this.state.metrics.tasksCompleted / this.state.metrics.tasksTotal) * 100);
  }

  /**
   * Calculate total time from tasks
   */
  private calculateTotalTime(tasks: Task[]): number {
    return tasks.reduce((total, task) => total + (task.estimatedTime || 0), 0) / 60; // Convert to hours
  }

  /**
   * Get next steps
   */
  private getNextSteps(): string[] {
    return this.state.activeTasks
      .filter((t) => t.status === 'pending')
      .sort((a, b) => (b.priority === 'critical' ? 1 : 0) - (a.priority === 'critical' ? 1 : 0))
      .slice(0, 3)
      .map((t) => t.title);
  }

  /**
   * Update metrics
   */
  private updateMetrics(): void {
    const metrics = this.state.metrics;
    metrics.progressPercentage = this.calculateOverallProgress();
    metrics.velocity =
      metrics.timeSpent > 0 ? metrics.tasksCompleted / (metrics.timeSpent / 60) : 0;

    if (metrics.velocity > 0) {
      const remainingTasks = metrics.tasksTotal - metrics.tasksCompleted;
      const remainingHours = remainingTasks / metrics.velocity;
      metrics.eta = new Date(Date.now() + remainingHours * 60 * 60 * 1000);
    }

    metrics.confidenceLevel = Math.min(100, metrics.tasksCompleted * 10);
  }

  /**
   * Get default configuration
   */
  private getDefaultConfig(): ActiveReportingConfig {
    return {
      autoGenerateSOW: true,
      requireSOWApproval: false,
      hourensouFrequency: {
        hou: 30, // Report every 30 minutes
        ren: 15, // Contact every 15 minutes
        sou: 5, // Consult threshold
      },
      proactiveTriggers: [
        {
          type: 'milestone',
          condition: 'task_completion',
          threshold: 25, // Every 25% progress
        },
        {
          type: 'blocker',
          condition: 'blocker_detected',
        },
        {
          type: 'hourensou',
          condition: 'interval',
          frequency: 30, // Every 30 minutes
        },
      ],
      visualizationStyle: 'detailed',
      taskDecompositionDepth: 3,
      confidenceThreshold: 80,
      enableAutoPlanning: true,
      enableLearning: true,
    };
  }

  /**
   * Dispose the service
   */
  public async dispose(): Promise<void> {
    if (this.reportingInterval) {
      clearInterval(this.reportingInterval);
    }

    await this.progressTracker.dispose();
    await this.proactiveReporter.dispose();

    this.removeAllListeners();
    this.isInitialized = false;
  }

  // Public API methods for CLI integration

  public async analyzeUserIntent(request: string, context?: unknown): Promise<IntentAnalysis> {
    return await this.analyzeIntent(request, context);
  }

  public async createTask(intent: IntentAnalysis): Promise<Task> {
    const task: Task = {
      id: crypto.randomUUID(),
      title: intent.keywords.slice(0, 3).join(' ') || 'New Task',
      description: `Task based on ${intent.primaryIntent}`,
      status: 'pending',
      priority: intent.urgency > 0.7 ? 'high' : intent.urgency > 0.4 ? 'medium' : 'low',
      estimatedTime: intent.estimatedEffort,
      dependencies: intent.dependencies,
      assignee: 'ai',
      progress: 0,
      metadata: {
        createdAt: new Date(),
        updatedAt: new Date(),
        intent,
      },
    };

    this.state.activeTasks.push(task);
    this.updateMetrics();

    return task;
  }

  public getTask(taskId: string): Task | undefined {
    return this.state.activeTasks.find((t) => t.id === taskId);
  }

  public getAllTasks(): Task[] {
    return [...this.state.activeTasks];
  }

  public getCurrentTasks(): Task[] {
    return this.state.activeTasks.filter((t) => t.status === 'in_progress');
  }

  public getCurrentSOW(): SOW | null {
    return this.state.currentSOW;
  }

  public async updateTaskEstimate(taskId: string, minutes: number): Promise<void> {
    const task = this.getTask(taskId);
    if (task) {
      task.estimatedTime = minutes;
      task.metadata.updatedAt = new Date();
      this.updateMetrics();
    }
  }

  public async setTaskDependencies(taskId: string, dependencies: string[]): Promise<void> {
    const task = this.getTask(taskId);
    if (task) {
      task.dependencies = dependencies;
      task.metadata.updatedAt = new Date();
    }
  }

  public async updateTaskProgress(taskId: string, progress: number): Promise<void> {
    const task = this.getTask(taskId);
    if (task) {
      task.progress = Math.max(0, Math.min(100, progress));
      task.metadata.updatedAt = new Date();

      if (progress === 100 && task.status !== 'completed') {
        await this.updateTaskStatus(taskId, 'completed');
      }

      this.updateMetrics();
    }
  }

  public getProgressData(): ProgressMetrics {
    return {
      totalTasks: this.state.metrics.tasksTotal,
      completedTasks: this.state.metrics.tasksCompleted,
      inProgressTasks: this.state.activeTasks.filter((t) => t.status === 'in_progress').length,
      blockedTasks: this.state.activeTasks.filter((t) => t.status === 'blocked').length,
      overallProgress: this.state.metrics.progressPercentage,
      estimatedTimeRemaining: this.state.metrics.timeRemaining,
      velocity: this.state.metrics.velocity,
      lastUpdated: new Date(),
    };
  }

  public visualizeProgress(progressData: ProgressMetrics): string {
    return this.taskVisualizer.renderProgressDashboard(progressData);
  }

  public async generateProgressReport(): Promise<ProgressReport> {
    const progressData = this.getProgressData();

    return {
      timestamp: new Date(),
      summary: `Overall progress: ${progressData.overallProgress}%`,
      completedTasks: this.state.activeTasks.filter((t) => t.status === 'completed'),
      currentTasks: this.state.activeTasks.filter((t) => t.status === 'in_progress'),
      upcomingTasks: this.state.activeTasks.filter((t) => t.status === 'pending'),
      blockers: [],
      recommendations: this.getNextSteps(),
      overallProgress: progressData.overallProgress,
    };
  }

  public async reportBlocker(description: string): Promise<void> {
    const blocker = {
      id: crypto.randomUUID(),
      title: description,
      description: description,
      severity: 'high' as const,
      affectedTasks: this.getCurrentTasks().map((t) => t.id),
      reportedAt: new Date(),
      reportedBy: 'user',
    };

    this.proactiveReporter.checkTriggers('blocker_detected', { blocker });
  }

  public exportReports(format: 'json' | 'markdown' = 'json'): string {
    return this.proactiveReporter.exportReports(format);
  }

  public async createSOWFromIntent(intent: IntentAnalysis): Promise<SOW> {
    return await this.generateSOW(intent, '');
  }
}
