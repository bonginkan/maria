/**
 * Active Reporting Service - Main Service
 * Core implementation for systematic Horenso and SOW/TODO management
 */

import { EventEmitter } from 'events';
import * as crypto from 'crypto';
import chalk from 'chalk';
import {
  Task,
  SOW,
  ProgressReport,
  HourensouReport,
  IntentAnalysis,
  TaskDecomposition,
  ProgressMetrics,
  ActiveReportingConfig,
  ServiceState,
  DecisionPoint,
  CollaborativePlan as _CollaborativePlan,
  ProactiveReportTrigger,
} from './types';
import { IntentAnalyzer } from './IntentAnalyzer';
import { SOWGenerator } from './SOWGenerator';
import { TaskDecomposer } from './TaskDecomposer';
import { ProgressTracker } from './ProgressTracker';
import { TaskVisualizer } from './TaskVisualizer';
import { ProactiveReporter } from './ProactiveReporter';
import { CollaborativePlanner } from './CollaborativePlanner';

export class ActiveReportingService extends EventEmitter {
  private static instance: ActiveReportingService;

  private state: ServiceState;
  private intentAnalyzer: IntentAnalyzer;
  private sowGenerator: SOWGenerator;
  private taskDecomposer: TaskDecomposer;
  private progressTracker: ProgressTracker;
  private taskVisualizer: TaskVisualizer;
  private proactiveReporter: ProactiveReporter;
  private collaborativePlanner: CollaborativePlanner;

  private reportingInterval?: NodeJS.Timeout;
  private lastReportTime: Date;
  private isInitialized: boolean = false;

  private constructor() {
    super();

    // Initialize default configuration
    this.state = {
      activeTasks: [],
      completedTasks: [],
      blockedTasks: [],
      pendingDecisions: [],
      reportHistory: [],
      metrics: {
        tasksCompleted: 0,
        tasksTotal: 0,
        progressPercentage: 0,
        timeSpent: 0,
        timeEstimated: 0,
        velocity: 0,
        eta: new Date(),
        confidenceLevel: 0,
      },
      config: this.getDefaultConfig(),
    };

    this.lastReportTime = new Date();

    // Initialize sub-services
    this.intentAnalyzer = new IntentAnalyzer();
    this.sowGenerator = new SOWGenerator();
    this.taskDecomposer = new TaskDecomposer();
    this.progressTracker = new ProgressTracker();
    this.taskVisualizer = new TaskVisualizer();
    this.proactiveReporter = new ProactiveReporter();
    this.collaborativePlanner = new CollaborativePlanner();
  }

  public static getInstance(): ActiveReportingService {
    if (!ActiveReportingService.instance) {
      ActiveReportingService.instance = new ActiveReportingService();
    }
    return ActiveReportingService.instance;
  }

  /**
   * Initialize the service
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) return;

    console.log(chalk.cyan('✨ Initializing Active Reporting Service...'));

    // Initialize sub-services
    await this.intentAnalyzer.initialize();
    await this.sowGenerator.initialize();
    await this.taskDecomposer.initialize();
    await this.progressTracker.initialize();
    await this.proactiveReporter.initialize();
    await this.collaborativePlanner.initialize();

    // Set up automatic reporting
    this.setupAutomaticReporting();

    // Set up event listeners
    this.setupEventListeners();

    this.isInitialized = true;
    console.log(chalk.green('✓ Active Reporting Service initialized'));
  }

  /**
   * Process user request with full Horenso workflow
   */
  public async processRequest(request: string, context?: unknown): Promise<SOW> {
    // Step 1: Analyze intent (理解)
    const intent = await this.analyzeIntent(request, context);

    // Step 2: Generate SOW (計画)
    const sow = await this.generateSOW(intent, request);

    // Step 3: Get approval (相談 - Sou)
    const approvedSOW = await this.getApproval(sow);

    // Step 4: Decompose into tasks (整理)
    const decomposition = await this.decomposeTasks(approvedSOW);

    // Step 5: Start execution with reporting (実行 + 報告)
    await this.startExecution(decomposition);

    return approvedSOW;
  }

  /**
   * Analyze user intent
   */
  private async analyzeIntent(request: string, context?: unknown): Promise<IntentAnalysis> {
    // Report: Starting analysis (Hou)
    await this.reportProgress({
      type: 'hourensou_hou',
      timestamp: new Date(),
      summary: '要求分析を開始します',
      completedTasks: [],
      currentTasks: [
        {
          id: crypto.randomUUID(),
          title: '意図分析',
          description: 'ユーザーの要求を理解しています',
          status: 'in_progress',
          priority: 'high',
          estimatedTime: 1,
          assignee: 'ai',
          progress: 50,
          dependencies: [],
          metadata: {
            createdAt: new Date(),
            updatedAt: new Date(),
            autoGenerated: true,
          },
        },
      ],
      upcomingTasks: [],
      blockers: [],
      recommendations: [],
      overallProgress: 0,
      nextSteps: ['意図分析完了', 'SOW生成'],
    });

    return await this.intentAnalyzer.analyze(request, context);
  }

  /**
   * Generate Statement of Work
   */
  private async generateSOW(intent: IntentAnalysis, request: string): Promise<SOW> {
    // Contact: SOW generation started (Ren)
    await this.contactUpdate({
      type: 'hourensou_ren',
      timestamp: new Date(),
      summary: 'SOW（作業計画書）を生成中です',
      completedTasks: [],
      currentTasks: [],
      upcomingTasks: [],
      blockers: [],
      recommendations: [],
      overallProgress: 10,
      nextSteps: ['SOW草案作成', 'リスク分析', 'タイムライン設定'],
    });

    const sow = await this.sowGenerator.generate(intent, request);

    // Visualize the SOW
    const visualization = this.taskVisualizer.visualizeSOW(sow);
    console.log(visualization);

    return sow;
  }

  /**
   * Get approval for SOW (Consultation - Sou)
   */
  private async getApproval(sow: SOW): Promise<SOW> {
    // Consult: Request approval (Sou)
    const decision: DecisionPoint = {
      id: crypto.randomUUID(),
      question: 'このSOWで作業を開始してよろしいですか？',
      context: `目的: ${sow.objective}\nタスク数: ${sow.tasks.length}\n推定時間: ${this.calculateTotalTime(sow.tasks)}時間`,
      options: [
        {
          id: 'approve',
          label: '承認',
          description: 'このプランで作業を開始します',
          pros: ['明確な計画', '詳細なタスク分解'],
          cons: [],
        },
        {
          id: 'modify',
          label: '修正',
          description: 'プランを修正します',
          pros: ['要件の精緻化'],
          cons: ['追加時間が必要'],
        },
        {
          id: 'reject',
          label: '却下',
          description: '別のアプローチを検討します',
          pros: ['根本的な見直し'],
          cons: ['計画の再作成が必要'],
        },
      ],
      recommendation: 'approve',
      impact: 'high',
    };

    await this.consultUser({
      type: 'hourensou_sou',
      timestamp: new Date(),
      summary: 'SOW承認が必要です',
      completedTasks: [],
      currentTasks: [],
      upcomingTasks: sow.tasks,
      blockers: [],
      recommendations: ['提案されたSOWは要件を満たしています'],
      overallProgress: 15,
      requiresUserInput: [decision],
      nextSteps: ['承認待ち', 'タスク実行準備'],
    });

    // For now, auto-approve if configured
    if (this.state.config.autoGenerateSOW && !this.state.config.requireSOWApproval) {
      sow.approvalStatus = 'approved';
      console.log(chalk.green('✓ SOW自動承認されました'));
    } else {
      // In real implementation, wait for user input
      sow.approvalStatus = 'approved';
    }

    return sow;
  }

  /**
   * Decompose SOW into executable tasks
   */
  private async decomposeTasks(sow: SOW): Promise<TaskDecomposition> {
    const decomposition = await this.taskDecomposer.decompose(sow);

    // Update state with new tasks
    this.state.activeTasks = decomposition.subtasks;
    this.state.metrics.tasksTotal = decomposition.subtasks.length;
    this.state.metrics.timeEstimated = decomposition.estimatedTotalTime;

    // Visualize task breakdown
    const visualization = this.taskVisualizer.visualizeTasks(decomposition.subtasks);
    console.log(visualization);

    return decomposition;
  }

  /**
   * Start task execution with reporting
   */
  private async startExecution(decomposition: TaskDecomposition): Promise<void> {
    this.state.currentSOW = await this.sowGenerator.createFromDecomposition(decomposition);

    // Report: Execution started (Hou)
    await this.reportProgress({
      type: 'hourensou_hou',
      timestamp: new Date(),
      summary: '作業を開始しました',
      completedTasks: [],
      currentTasks: decomposition.subtasks.filter((t) => t.status === 'in_progress'),
      upcomingTasks: decomposition.subtasks.filter((t) => t.status === 'pending'),
      blockers: [],
      recommendations:
        decomposition.parallelizableGroups.length > 0 ? ['並列実行可能なタスクがあります'] : [],
      overallProgress: 20,
      visualRepresentation: this.taskVisualizer.visualizeProgress(this.state.metrics),
      nextSteps: decomposition.criticalPath
        .slice(0, 3)
        .map((id) => {
          const task = decomposition.subtasks.find((t) => t.id === id);
          return task ? task.title : '';
        })
        .filter(Boolean),
    });

    // Start progress tracking
    await this.progressTracker.startTracking(this.state.activeTasks);
  }

  /**
   * Report progress (Hou - 報告)
   */
  private async reportProgress(report: ProgressReport): Promise<void> {
    console.log(chalk.blue('\n📊 進捗報告 (Hou):'));
    console.log(chalk.gray('─'.repeat(50)));
    console.log(report.summary);

    if (report.visualRepresentation) {
      console.log(report.visualRepresentation);
    }

    this.state.reportHistory.push(report);
    this.emit('progress:reported', report);
  }

  /**
   * Send update (Ren - 連絡)
   */
  private async contactUpdate(report: ProgressReport): Promise<void> {
    console.log(chalk.yellow('\n📢 連絡事項 (Ren):'));
    console.log(chalk.gray('─'.repeat(50)));
    console.log(report.summary);

    if (report.nextSteps && report.nextSteps.length > 0) {
      console.log(chalk.gray('\n次のステップ:'));
      report.nextSteps.forEach((step, i) => {
        console.log(chalk.gray(`  ${i + 1}. ${step}`));
      });
    }

    this.state.reportHistory.push(report);
    this.emit('update:sent', report);
  }

  /**
   * Consult user (Sou - 相談)
   */
  private async consultUser(report: ProgressReport): Promise<void> {
    console.log(chalk.magenta('\n💭 相談事項 (Sou):'));
    console.log(chalk.gray('─'.repeat(50)));
    console.log(report.summary);

    if (report.requiresUserInput && report.requiresUserInput.length > 0) {
      for (const decision of report.requiresUserInput) {
        console.log(chalk.cyan(`\n質問: ${decision.question}`));
        console.log(chalk.gray(`コンテキスト: ${decision.context}`));

        if (decision.options) {
          console.log(chalk.gray('\nオプション:'));
          decision.options.forEach((option) => {
            console.log(chalk.white(`  • ${option.label}: ${option.description}`));
          });
        }

        if (decision.recommendation) {
          console.log(chalk.green(`\n推奨: ${decision.recommendation}`));
        }
      }
    }

    this.state.reportHistory.push(report);
    this.emit('consultation:requested', report);
  }

  /**
   * Update task status
   */
  public async updateTaskStatus(
    taskId: string,
    status: Task['status'],
    progress?: number,
  ): Promise<void> {
    const task = this.state.activeTasks.find((t) => t.id === taskId);
    if (!task) return;

    const oldStatus = task.status;
    task.status = status;
    if (progress !== undefined) {
      task.progress = progress;
    }

    // Handle status transitions
    if (status === 'completed' && oldStatus !== 'completed') {
      this.state.completedTasks.push(task);
      this.state.activeTasks = this.state.activeTasks.filter((t) => t.id !== taskId);
      this.state.metrics.tasksCompleted++;

      // Report completion (Hou)
      await this.reportProgress({
        type: 'hourensou_hou',
        timestamp: new Date(),
        summary: `タスク完了: ${task.title}`,
        completedTasks: [task],
        currentTasks: this.state.activeTasks.filter((t) => t.status === 'in_progress'),
        upcomingTasks: this.state.activeTasks.filter((t) => t.status === 'pending'),
        blockers: [],
        recommendations: [],
        overallProgress: this.calculateOverallProgress(),
        nextSteps: this.getNextSteps(),
      });
    } else if (status === 'blocked' && oldStatus !== 'blocked') {
      this.state.blockedTasks.push(task);

      // Consult on blocker (Sou)
      await this.consultUser({
        type: 'hourensou_sou',
        timestamp: new Date(),
        summary: `タスクがブロックされました: ${task.title}`,
        completedTasks: [],
        currentTasks: [],
        upcomingTasks: [],
        blockers: [
          {
            id: crypto.randomUUID(),
            taskId: task.id,
            description: `${task.title} がブロックされています`,
            severity: 'high',
            identifiedAt: new Date(),
            impact: '後続タスクの遅延',
          },
        ],
        recommendations: ['ブロッカーの解消が必要です'],
        overallProgress: this.calculateOverallProgress(),
        requiresUserInput: [
          {
            id: crypto.randomUUID(),
            question: 'どのように対処しますか？',
            context: `タスク: ${task.title}`,
            options: [
              {
                id: 'wait',
                label: '待機',
                description: 'ブロッカーが解消されるまで待機',
                pros: ['依存関係を維持'],
                cons: ['進捗の停滞'],
              },
              {
                id: 'skip',
                label: 'スキップ',
                description: '他のタスクを先に実行',
                pros: ['進捗を継続'],
                cons: ['依存関係の崩れ'],
              },
              {
                id: 'resolve',
                label: '解決',
                description: 'ブロッカーを即座に解決',
                pros: ['問題の根本解決'],
                cons: ['追加時間が必要'],
              },
            ],
            impact: 'high',
          },
        ],
        nextSteps: ['ブロッカー解消', '代替タスク実行'],
      });
    }

    // Update metrics
    this.updateMetrics();
  }

  /**
   * Setup automatic reporting intervals
   */
  private setupAutomaticReporting(): void {
    const config = this.state.config.hourensouFrequency;

    // Regular progress reports (Hou)
    this.reportingInterval = setInterval(
      async () => {
        if (this.state.activeTasks.length > 0) {
          await this.generateHourensouReport();
        }
      },
      config.hou * 60 * 1000,
    );
  }

  /**
   * Generate comprehensive Hourensou report
   */
  private async generateHourensouReport(): Promise<void> {
    const report: HourensouReport = {
      hou: [
        {
          type: 'progress',
          title: '進捗状況',
          details: `完了: ${this.state.metrics.tasksCompleted}/${this.state.metrics.tasksTotal} タスク`,
          impact: `進捗率: ${this.state.metrics.progressPercentage}%`,
        },
      ],
      ren: [
        {
          type: 'update',
          title: '現在の作業',
          message:
            this.state.activeTasks
              .filter((t) => t.status === 'in_progress')
              .map((t) => t.title)
              .join(', ') || 'なし',
          urgency: 'normal',
        },
      ],
      sou:
        this.state.blockedTasks.length > 0
          ? [
              {
                type: 'technical',
                question: 'ブロックされたタスクの対処方法',
                context: `${this.state.blockedTasks.length}個のタスクがブロックされています`,
              },
            ]
          : [],
      timestamp: new Date(),
      context: this.state.currentSOW?.title || 'Active Reporting',
    };

    this.state.lastHourensou = report;

    // Display the report
    const visualization = this.taskVisualizer.visualizeHourensou(report);
    console.log(visualization);

    this.emit('hourensou:generated', report);
  }

  /**
   * Setup event listeners
   */
  private setupEventListeners(): void {
    // Listen to progress tracker events
    this.progressTracker.on('task:started', (task: Task) => {
      this.updateTaskStatus(task.id, 'in_progress', 0);
    });

    this.progressTracker.on('task:progressed', (task: Task, progress: number) => {
      this.updateTaskStatus(task.id, 'in_progress', progress);
    });

    this.progressTracker.on('task:completed', (task: Task) => {
      this.updateTaskStatus(task.id, 'completed', 100);
    });

    this.progressTracker.on('task:blocked', (task: Task) => {
      this.updateTaskStatus(task.id, 'blocked');
    });

    // Listen to proactive reporter events
    this.proactiveReporter.on('trigger:activated', (trigger: ProactiveReportTrigger) => {
      this.handleProactiveTrigger(trigger);
    });
  }

  /**
   * Handle proactive reporting trigger
   */
  private async handleProactiveTrigger(trigger: ProactiveReportTrigger): Promise<void> {
    switch (trigger.type) {
      case 'milestone':
        await this.reportProgress({
          type: 'milestone',
          timestamp: new Date(),
          summary: 'マイルストーン達成！',
          completedTasks: this.state.completedTasks.slice(-5),
          currentTasks: this.state.activeTasks.filter((t) => t.status === 'in_progress'),
          upcomingTasks: this.state.activeTasks.filter((t) => t.status === 'pending').slice(0, 5),
          blockers: [],
          recommendations: [],
          overallProgress: this.calculateOverallProgress(),
          nextSteps: this.getNextSteps(),
        });
        break;

      case 'blocker':
        await this.consultUser({
          type: 'blocker',
          timestamp: new Date(),
          summary: 'ブロッカーが検出されました',
          completedTasks: [],
          currentTasks: [],
          upcomingTasks: [],
          blockers: this.state.blockedTasks.map((task) => ({
            id: crypto.randomUUID(),
            taskId: task.id,
            description: `${task.title} is blocked`,
            severity: 'high',
            identifiedAt: new Date(),
            impact: 'Progress halted',
          })),
          recommendations: ['Immediate attention required'],
          overallProgress: this.calculateOverallProgress(),
          nextSteps: ['Resolve blockers', 'Find alternative paths'],
        });
        break;

      case 'hourensou':
        await this.generateHourensouReport();
        break;
    }
  }

  /**
   * Calculate overall progress
   */
  private calculateOverallProgress(): number {
    if (this.state.metrics.tasksTotal === 0) return 0;
    return Math.round((this.state.metrics.tasksCompleted / this.state.metrics.tasksTotal) * 100);
  }

  /**
   * Calculate total time from tasks
   */
  private calculateTotalTime(tasks: Task[]): number {
    return tasks.reduce((total, task) => total + (task.estimatedTime || 0), 0) / 60; // Convert to hours
  }

  /**
   * Get next steps
   */
  private getNextSteps(): string[] {
    return this.state.activeTasks
      .filter((t) => t.status === 'pending')
      .sort((a, b) => (b.priority === 'critical' ? 1 : 0) - (a.priority === 'critical' ? 1 : 0))
      .slice(0, 3)
      .map((t) => t.title);
  }

  /**
   * Update metrics
   */
  private updateMetrics(): void {
    const metrics = this.state.metrics;
    metrics.progressPercentage = this.calculateOverallProgress();
    metrics.velocity =
      metrics.timeSpent > 0 ? metrics.tasksCompleted / (metrics.timeSpent / 60) : 0;

    if (metrics.velocity > 0) {
      const remainingTasks = metrics.tasksTotal - metrics.tasksCompleted;
      const remainingHours = remainingTasks / metrics.velocity;
      metrics.eta = new Date(Date.now() + remainingHours * 60 * 60 * 1000);
    }

    metrics.confidenceLevel = Math.min(100, metrics.tasksCompleted * 10);
  }

  /**
   * Get default configuration
   */
  private getDefaultConfig(): ActiveReportingConfig {
    return {
      autoGenerateSOW: true,
      requireSOWApproval: false,
      hourensouFrequency: {
        hou: 30, // Report every 30 minutes
        ren: 15, // Contact every 15 minutes
        sou: 5, // Consult threshold
      },
      proactiveTriggers: [
        {
          type: 'milestone',
          condition: 'task_completion',
          threshold: 25, // Every 25% progress
        },
        {
          type: 'blocker',
          condition: 'blocker_detected',
        },
        {
          type: 'hourensou',
          condition: 'interval',
          frequency: 30, // Every 30 minutes
        },
      ],
      visualizationStyle: 'detailed',
      taskDecompositionDepth: 3,
      confidenceThreshold: 80,
      enableAutoPlanning: true,
      enableLearning: true,
    };
  }

  /**
   * Dispose the service
   */
  public async dispose(): Promise<void> {
    if (this.reportingInterval) {
      clearInterval(this.reportingInterval);
    }

    await this.progressTracker.dispose();
    await this.proactiveReporter.dispose();

    this.removeAllListeners();
    this.isInitialized = false;
  }

  // Public API methods for CLI integration

  public async analyzeUserIntent(request: string, context?: unknown): Promise<IntentAnalysis> {
    return await this.analyzeIntent(request, context);
  }

  public async createTask(intent: IntentAnalysis): Promise<Task> {
    const task: Task = {
      id: crypto.randomUUID(),
      title: intent.keywords.slice(0, 3).join(' ') || 'New Task',
      description: `Task based on ${intent.primaryIntent}`,
      status: 'pending',
      priority: intent.urgency > 0.7 ? 'high' : intent.urgency > 0.4 ? 'medium' : 'low',
      estimatedTime: intent.estimatedEffort,
      dependencies: intent.dependencies,
      assignee: 'ai',
      progress: 0,
      metadata: {
        createdAt: new Date(),
        updatedAt: new Date(),
        intent,
      },
    };

    this.state.activeTasks.push(task);
    this.updateMetrics();

    return task;
  }

  public getTask(taskId: string): Task | undefined {
    return this.state.activeTasks.find((t) => t.id === taskId);
  }

  public getAllTasks(): Task[] {
    return [...this.state.activeTasks];
  }

  public getCurrentTasks(): Task[] {
    return this.state.activeTasks.filter((t) => t.status === 'in_progress');
  }

  public getCurrentSOW(): SOW | null {
    return this.state.currentSOW;
  }

  public async updateTaskEstimate(taskId: string, minutes: number): Promise<void> {
    const task = this.getTask(taskId);
    if (task) {
      task.estimatedTime = minutes;
      task.metadata.updatedAt = new Date();
      this.updateMetrics();
    }
  }

  public async setTaskDependencies(taskId: string, dependencies: string[]): Promise<void> {
    const task = this.getTask(taskId);
    if (task) {
      task.dependencies = dependencies;
      task.metadata.updatedAt = new Date();
    }
  }

  public async updateTaskProgress(taskId: string, progress: number): Promise<void> {
    const task = this.getTask(taskId);
    if (task) {
      task.progress = Math.max(0, Math.min(100, progress));
      task.metadata.updatedAt = new Date();

      if (progress === 100 && task.status !== 'completed') {
        await this.updateTaskStatus(taskId, 'completed');
      }

      this.updateMetrics();
    }
  }

  public getProgressData(): ProgressMetrics {
    return {
      totalTasks: this.state.metrics.tasksTotal,
      completedTasks: this.state.metrics.tasksCompleted,
      inProgressTasks: this.state.activeTasks.filter((t) => t.status === 'in_progress').length,
      blockedTasks: this.state.activeTasks.filter((t) => t.status === 'blocked').length,
      overallProgress: this.state.metrics.progressPercentage,
      estimatedTimeRemaining: this.state.metrics.timeRemaining,
      velocity: this.state.metrics.velocity,
      lastUpdated: new Date(),
    };
  }

  public visualizeProgress(progressData: ProgressMetrics): string {
    return this.taskVisualizer.renderProgressDashboard(progressData);
  }

  public async generateProgressReport(): Promise<ProgressReport> {
    const progressData = this.getProgressData();

    return {
      timestamp: new Date(),
      summary: `Overall progress: ${progressData.overallProgress}%`,
      completedTasks: this.state.activeTasks.filter((t) => t.status === 'completed'),
      currentTasks: this.state.activeTasks.filter((t) => t.status === 'in_progress'),
      upcomingTasks: this.state.activeTasks.filter((t) => t.status === 'pending'),
      blockers: [],
      recommendations: this.getNextSteps(),
      overallProgress: progressData.overallProgress,
    };
  }

  public async reportBlocker(description: string): Promise<void> {
    const blocker = {
      id: crypto.randomUUID(),
      title: description,
      description: description,
      severity: 'high' as const,
      affectedTasks: this.getCurrentTasks().map((t) => t.id),
      reportedAt: new Date(),
      reportedBy: 'user',
    };

    this.proactiveReporter.checkTriggers('blocker_detected', { blocker });
  }

  public exportReports(format: 'json' | 'markdown' = 'json'): string {
    return this.proactiveReporter.exportReports(format);
  }

  public async createSOWFromIntent(intent: IntentAnalysis): Promise<SOW> {
    return await this.generateSOW(intent, '');
  }
}
