/**
 * Task Visualizer - Beautiful CLI visualization for tasks and progress
 * Implements the 124-character responsive design framework
 */

import chalk from 'chalk';
import {
  Task,
  SOW,
  ProgressMetrics,
  HourensouReport,
  ProgressReport,
  DecisionPoint,
} from './types';

export class TaskVisualizer {
  private readonly WIDTH = 124;
  private readonly BORDER_CHAR = '‚ïê';
  private readonly VERTICAL_CHAR = '‚ïë';
  private readonly CORNER_TL = '‚ïî';
  private readonly CORNER_TR = '‚ïó';
  private readonly CORNER_BL = '‚ïö';
  private readonly CORNER_BR = '‚ïù';

  // Status icons (no emoji for compatibility)
  private readonly ICONS = {
    completed: chalk.green('‚úì'),
    in_progress: chalk.yellow('‚†ã'),
    pending: chalk.gray('‚óã'),
    blocked: chalk.red('‚úó'),
    deferred: chalk.gray('!'),
    arrow: chalk.cyan('‚Üí'),
    bullet: chalk.gray('‚Ä¢'),
  };

  /**
   * Visualize SOW
   */
  public visualizeSOW(sow: SOW): string {
    const lines: string[] = [];

    // Header
    lines.push(this.createHeader('SOW: ' + sow.title));
    lines.push('');

    // Objective
    lines.push(chalk.cyan('Objective:'));
    lines.push(this.wrapText(sow.objective, 2));
    lines.push('');

    // Scope
    lines.push(chalk.cyan('Scope:'));
    sow.scope.forEach((item) => {
      lines.push(`  ${this.ICONS.bullet} ${item}`);
    });
    lines.push('');

    // Timeline
    if (sow.timeline) {
      lines.push(chalk.cyan('Timeline:'));
      lines.push(`  Start: ${sow.timeline.startDate.toLocaleDateString()}`);
      lines.push(`  End: ${sow.timeline.endDate.toLocaleDateString()}`);
      const duration =
        (sow.timeline.endDate.getTime() - sow.timeline.startDate.getTime()) / (1000 * 60 * 60);
      lines.push(`  Duration: ${duration.toFixed(1)} hours`);
      lines.push('');
    }

    // Tasks
    lines.push(chalk.cyan(`Tasks (${sow.tasks.length}):`));
    sow.tasks.slice(0, 10).forEach((task, index) => {
      lines.push(this.formatTask(task, index + 1));
    });
    if (sow.tasks.length > 10) {
      lines.push(chalk.gray(`  ... and ${sow.tasks.length - 10} more tasks`));
    }
    lines.push('');

    // Risks
    if (sow.risks && sow.risks.length > 0) {
      lines.push(chalk.yellow('Risks:'));
      sow.risks.forEach((risk) => {
        const color =
          risk.impact === 'critical'
            ? chalk.red
            : risk.impact === 'high'
              ? chalk.yellow
              : chalk.gray;
        lines.push(`  ${color('!')} ${risk.description}`);
      });
      lines.push('');
    }

    // Footer
    lines.push(this.createFooter(`Version: ${sow.version} | Status: ${sow.approvalStatus}`));

    return lines.join('\n');
  }

  /**
   * Visualize tasks with hierarchy
   */
  public visualizeTasks(tasks: Task[]): string {
    const lines: string[] = [];

    lines.push(this.createHeader('Task Breakdown'));
    lines.push('');

    // Group tasks by status
    const grouped = this.groupTasksByStatus(tasks);

    // In Progress
    if (grouped.in_progress.length > 0) {
      lines.push(chalk.yellow('‚è∫ In Progress:'));
      grouped.in_progress.forEach((task) => {
        lines.push(this.formatTaskWithProgress(task));
      });
      lines.push('');
    }

    // Pending
    if (grouped.pending.length > 0) {
      lines.push(chalk.cyan('‚èπ Pending:'));
      grouped.pending.forEach((task) => {
        lines.push(this.formatTaskSimple(task));
      });
      lines.push('');
    }

    // Blocked
    if (grouped.blocked.length > 0) {
      lines.push(chalk.red('‚ö†Ô∏è Blocked:'));
      grouped.blocked.forEach((task) => {
        lines.push(this.formatTaskWithBlocker(task));
      });
      lines.push('');
    }

    // Completed
    if (grouped.completed.length > 0) {
      lines.push(chalk.green('‚úÖ Completed:'));
      grouped.completed.slice(0, 5).forEach((task) => {
        lines.push(this.formatTaskSimple(task));
      });
      if (grouped.completed.length > 5) {
        lines.push(chalk.gray(`  ... and ${grouped.completed.length - 5} more`));
      }
      lines.push('');
    }

    // Summary
    lines.push(this.createSummaryBar(tasks));

    return lines.join('\n');
  }

  /**
   * Visualize progress metrics
   */
  public visualizeProgress(metrics: ProgressMetrics): string {
    const lines: string[] = [];

    lines.push(this.createHeader('Progress Report'));
    lines.push('');

    // Progress bar
    lines.push(chalk.cyan('Overall Progress:'));
    lines.push(this.createProgressBar(metrics.progressPercentage));
    lines.push('');

    // Metrics grid
    lines.push(this.createMetricsGrid(metrics));
    lines.push('');

    // Velocity chart
    lines.push(chalk.cyan('Velocity:'));
    lines.push(this.createVelocityChart(metrics.velocity));
    lines.push('');

    // ETA
    lines.push(chalk.cyan('Estimated Completion:'));
    lines.push(`  ${metrics.eta.toLocaleString()}`);
    lines.push(`  Confidence: ${this.createConfidenceIndicator(metrics.confidenceLevel)}`);

    return lines.join('\n');
  }

  /**
   * Visualize Hourensou report
   */
  public visualizeHourensou(report: HourensouReport): string {
    const lines: string[] = [];

    lines.push(this.createHeader('„Éõ„Ç¶„É¨„É≥„ÇΩ„Ç¶ (Hourensou) Report'));
    lines.push('');

    // Hou (Â†±Âëä - Report)
    if (report.hou.length > 0) {
      lines.push(chalk.blue('üìä Â†±Âëä (Hou - Report):'));
      lines.push(chalk.gray('‚îÄ'.repeat(50)));
      report.hou.forEach((item) => {
        const icon =
          item.type === 'completion'
            ? this.ICONS.completed
            : item.type === 'progress'
              ? this.ICONS.in_progress
              : item.type === 'issue'
                ? this.ICONS.blocked
                : this.ICONS.bullet;
        lines.push(`${icon} ${item.title}`);
        lines.push(chalk.gray(`  ${item.details}`));
        if (item.impact) {
          lines.push(chalk.yellow(`  Impact: ${item.impact}`));
        }
      });
      lines.push('');
    }

    // Ren (ÈÄ£Áµ° - Contact)
    if (report.ren.length > 0) {
      lines.push(chalk.yellow('üì¢ ÈÄ£Áµ° (Ren - Contact):'));
      lines.push(chalk.gray('‚îÄ'.repeat(50)));
      report.ren.forEach((item) => {
        const urgencyColor =
          item.urgency === 'critical'
            ? chalk.red
            : item.urgency === 'high'
              ? chalk.yellow
              : item.urgency === 'normal'
                ? chalk.white
                : chalk.gray;
        lines.push(`${urgencyColor('!')} ${item.title}`);
        lines.push(chalk.gray(`  ${item.message}`));
      });
      lines.push('');
    }

    // Sou (Áõ∏Ë´á - Consult)
    if (report.sou.length > 0) {
      lines.push(chalk.magenta('üí≠ Áõ∏Ë´á (Sou - Consult):'));
      lines.push(chalk.gray('‚îÄ'.repeat(50)));
      report.sou.forEach((item) => {
        lines.push(`‚ùì ${item.question}`);
        lines.push(chalk.gray(`  Context: ${item.context}`));
        if (item.recommendation) {
          lines.push(chalk.green(`  Recommendation: ${item.recommendation}`));
        }
      });
      lines.push('');
    }

    lines.push(this.createFooter(`Generated: ${report.timestamp.toLocaleString()}`));

    return lines.join('\n');
  }

  /**
   * Visualize decision point
   */
  public visualizeDecision(decision: DecisionPoint): string {
    const lines: string[] = [];

    lines.push(this.createHeader('Decision Required'));
    lines.push('');

    lines.push(chalk.yellow('‚ùì ' + decision.question));
    lines.push('');

    lines.push(chalk.gray('Context:'));
    lines.push(this.wrapText(decision.context, 2));
    lines.push('');

    if (decision.options && decision.options.length > 0) {
      lines.push(chalk.cyan('Options:'));
      decision.options.forEach((option, index) => {
        const letter = String.fromCharCode(97 + index); // a, b, c...
        lines.push(`  ${chalk.bold(letter + ')')} ${option.label}`);
        lines.push(chalk.gray(`     ${option.description}`));

        if (option.pros && option.pros.length > 0) {
          lines.push(chalk.green(`     Pros: ${option.pros.join(', ')}`));
        }

        if (option.cons && option.cons.length > 0) {
          lines.push(chalk.red(`     Cons: ${option.cons.join(', ')}`));
        }

        if (option.estimatedTime) {
          lines.push(chalk.gray(`     Time: ${option.estimatedTime} minutes`));
        }

        lines.push('');
      });
    }

    if (decision.recommendation) {
      lines.push(chalk.green(`Recommendation: ${decision.recommendation}`));
    }

    if (decision.deadline) {
      lines.push(chalk.yellow(`Deadline: ${decision.deadline.toLocaleString()}`));
    }

    return lines.join('\n');
  }

  /**
   * Create beautiful progress visualization
   */
  public createBeautifulProgress(report: ProgressReport): string {
    const lines: string[] = [];

    // Main header
    lines.push(this.createDoubleLineHeader('ACTIVE TASK MANAGEMENT'));
    lines.push('');

    // Current objective
    if (report.summary) {
      lines.push(`  ${chalk.cyan('üéØ')} Current Objective: ${chalk.bold(report.summary)}`);
      lines.push(
        `  ${chalk.blue('üìä')} Overall Progress: ${this.createInlineProgressBar(report.overallProgress)}`,
      );
      lines.push('');
    }

    // Task tree visualization
    lines.push('  ‚è∫ Update Todos');

    // Current tasks
    report.currentTasks.forEach((task) => {
      const icon =
        task.status === 'completed'
          ? chalk.green('‚úÖ')
          : task.status === 'in_progress'
            ? chalk.yellow('üîÑ')
            : task.status === 'blocked'
              ? chalk.red('‚è∏')
              : chalk.gray('‚èπ');

      const progress =
        task.status === 'in_progress' && task.progress ? chalk.gray(` [${task.progress}%]`) : '';

      lines.push(`    ‚éø  ${icon} ${task.title}${progress}`);
    });

    // Upcoming tasks
    report.upcomingTasks.slice(0, 5).forEach((task) => {
      lines.push(`       ${chalk.gray('‚èπ')} ${chalk.gray(task.title)}`);
    });

    if (report.upcomingTasks.length > 5) {
      lines.push(`       ${chalk.gray(`... and ${report.upcomingTasks.length - 5} more`)}`);
    }

    lines.push('');

    // Statistics section
    const completedCount = report.completedTasks.length;
    const totalCount = completedCount + report.currentTasks.length + report.upcomingTasks.length;
    const timeSpent = this.formatTime(
      report.completedTasks.reduce((sum, t) => sum + (t.actualTime || 0), 0),
    );
    const timeEstimated = this.formatTime(totalCount * 60); // Rough estimate

    lines.push(`  ${chalk.cyan('üìà')} Statistics`);
    lines.push(
      `    ${this.ICONS.bullet} Completed: ${completedCount}/${totalCount} tasks (${Math.round((completedCount / totalCount) * 100)}%)`,
    );
    lines.push(`    ${this.ICONS.bullet} Time Spent: ${timeSpent} / Est: ${timeEstimated}`);
    lines.push(
      `    ${this.ICONS.bullet} Velocity: ${(completedCount / (parseInt(timeSpent) || 1)).toFixed(1)} tasks/hour`,
    );
    lines.push(
      `    ${this.ICONS.bullet} ETA: ${this.calculateETA(totalCount - completedCount, 1.5)}`,
    );
    lines.push('');

    // Blockers & Risks
    if (report.blockers && report.blockers.length > 0) {
      lines.push(`  ${chalk.yellow('‚ö†Ô∏è')} Blockers & Risks`);
      report.blockers.forEach((blocker) => {
        lines.push(`    ${this.ICONS.bullet} ${blocker.description}`);
      });
      lines.push('');
    }

    // AI Recommendations
    if (report.recommendations && report.recommendations.length > 0) {
      lines.push(`  ${chalk.blue('üí°')} AI Recommendations`);
      report.recommendations.forEach((rec) => {
        lines.push(`    ${this.ICONS.bullet} ${rec}`);
      });
      lines.push('');
    }

    // Footer
    lines.push(this.createDoubleLineFooter());

    return lines.join('\n');
  }

  // Helper methods

  private createHeader(title: string): string {
    const titleLength = title.length;
    const totalPadding = this.WIDTH - titleLength - 4; // 4 for corners and spaces
    const leftPadding = Math.floor(totalPadding / 2);
    const rightPadding = totalPadding - leftPadding;

    const top = this.CORNER_TL + this.BORDER_CHAR.repeat(this.WIDTH - 2) + this.CORNER_TR;
    const middle =
      this.VERTICAL_CHAR +
      ' '.repeat(leftPadding) +
      chalk.bold(title) +
      ' '.repeat(rightPadding) +
      this.VERTICAL_CHAR;
    const bottom = this.CORNER_BL + this.BORDER_CHAR.repeat(this.WIDTH - 2) + this.CORNER_BR;

    return `${top}\n${middle}\n${bottom}`;
  }

  private createDoubleLineHeader(title: string): string {
    const line = '‚ïê'.repeat(this.WIDTH);
    const titleLine = this.centerText(title, this.WIDTH);

    return `‚ïî${line.slice(2)}‚ïó\n‚ïë${titleLine.slice(2)}‚ïë\n‚ï†${line.slice(2)}‚ï£`;
  }

  private createDoubleLineFooter(): string {
    const line = '‚ïê'.repeat(this.WIDTH);
    return `‚ïö${line.slice(2)}‚ïù`;
  }

  private createFooter(text: string): string {
    const padding = this.WIDTH - text.length - 4;
    const leftPad = Math.floor(padding / 2);
    const rightPad = padding - leftPad;

    return (
      this.CORNER_BL +
      this.BORDER_CHAR +
      ' '.repeat(leftPad) +
      chalk.gray(text) +
      ' '.repeat(rightPad) +
      this.BORDER_CHAR +
      this.CORNER_BR
    );
  }

  private createProgressBar(percentage: number): string {
    const width = 50;
    const filled = Math.round((percentage / 100) * width);
    const empty = width - filled;

    const bar = chalk.green('‚ñà'.repeat(filled)) + chalk.gray('‚ñë'.repeat(empty));
    const percentText = `${percentage.toFixed(1)}%`.padStart(6);

    return `  ${bar} ${chalk.cyan(percentText)}`;
  }

  private createInlineProgressBar(percentage: number): string {
    const width = 30;
    const filled = Math.round((percentage / 100) * width);
    const empty = width - filled;

    const bar = chalk.green('‚ñà'.repeat(filled)) + chalk.gray('‚ñë'.repeat(empty));
    return `${bar} ${percentage}%`;
  }

  private createVelocityChart(velocity: number): string {
    const maxBars = 20;
    const bars = Math.min(maxBars, Math.round(velocity * 5));
    const chart = '‚ñÉ'.repeat(bars);

    return `  ${chalk.cyan(chart)} ${velocity.toFixed(2)} tasks/hour`;
  }

  private createConfidenceIndicator(confidence: number): string {
    const stars = Math.round(confidence / 20);
    return '‚òÖ'.repeat(stars) + '‚òÜ'.repeat(5 - stars) + ` (${confidence}%)`;
  }

  private createMetricsGrid(metrics: ProgressMetrics): string {
    const lines: string[] = [];

    lines.push('  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
    lines.push(`  ‚îÇ Tasks Completed     ‚îÇ ${String(metrics.tasksCompleted).padStart(18)} ‚îÇ`);
    lines.push(`  ‚îÇ Tasks Total         ‚îÇ ${String(metrics.tasksTotal).padStart(18)} ‚îÇ`);
    lines.push('  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§');
    lines.push(`  ‚îÇ Time Spent          ‚îÇ ${(metrics.timeSpent + ' min').padStart(18)} ‚îÇ`);
    lines.push(`  ‚îÇ Time Estimated      ‚îÇ ${(metrics.timeEstimated + ' min').padStart(18)} ‚îÇ`);
    lines.push('  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

    return lines.join('\n');
  }

  private createSummaryBar(tasks: Task[]): string {
    const total = tasks.length;
    const completed = tasks.filter((t) => t.status === 'completed').length;
    const inProgress = tasks.filter((t) => t.status === 'in_progress').length;
    const blocked = tasks.filter((t) => t.status === 'blocked').length;
    const pending = tasks.filter((t) => t.status === 'pending').length;

    return chalk.gray(
      `Summary: ${chalk.green(`‚úì ${completed}`)} | ` +
        `${chalk.yellow(`‚†ã ${inProgress}`)} | ` +
        `${chalk.red(`‚úó ${blocked}`)} | ` +
        `${chalk.gray(`‚óã ${pending}`)} | ` +
        `Total: ${total}`,
    );
  }

  private formatTask(task: Task, index: number): string {
    const icon = this.getStatusIcon(task.status);
    const priority =
      task.priority === 'critical'
        ? chalk.red('[!]')
        : task.priority === 'high'
          ? chalk.yellow('[H]')
          : '';
    const time = task.estimatedTime ? chalk.gray(` (${task.estimatedTime}m)`) : '';

    return `  ${index}. ${icon} ${priority} ${task.title}${time}`;
  }

  private formatTaskWithProgress(task: Task): string {
    const progress = task.progress || 0;
    const progressBar = this.createMiniProgressBar(progress);
    const time = task.actualTime
      ? chalk.gray(` (${task.actualTime.toFixed(0)}/${task.estimatedTime || '?'}m)`)
      : '';

    return `  ${this.ICONS.in_progress} ${task.title} ${progressBar}${time}`;
  }

  private formatTaskSimple(task: Task): string {
    const icon = this.getStatusIcon(task.status);
    return `  ${icon} ${task.title}`;
  }

  private formatTaskWithBlocker(task: Task): string {
    const blocker = task.blockers && task.blockers[0] ? chalk.red(` - ${task.blockers[0]}`) : '';
    return `  ${this.ICONS.blocked} ${task.title}${blocker}`;
  }

  private createMiniProgressBar(percentage: number): string {
    const width = 10;
    const filled = Math.round((percentage / 100) * width);
    const empty = width - filled;

    return (
      chalk.gray('[') +
      chalk.green('='.repeat(filled)) +
      chalk.gray('-'.repeat(empty)) +
      chalk.gray(']') +
      chalk.cyan(` ${percentage}%`)
    );
  }

  private getStatusIcon(status: Task['status']): string {
    return this.ICONS[status] || this.ICONS.pending;
  }

  private groupTasksByStatus(tasks: Task[]): Record<Task['status'], Task[]> {
    return {
      pending: tasks.filter((t) => t.status === 'pending'),
      in_progress: tasks.filter((t) => t.status === 'in_progress'),
      completed: tasks.filter((t) => t.status === 'completed'),
      blocked: tasks.filter((t) => t.status === 'blocked'),
      deferred: tasks.filter((t) => t.status === 'deferred'),
    };
  }

  private wrapText(text: string, indent: number = 0): string {
    const maxWidth = this.WIDTH - indent - 4;
    const words = text.split(' ');
    const lines: string[] = [];
    let currentLine = '';

    words.forEach((word) => {
      if ((currentLine + word).length > maxWidth) {
        lines.push(' '.repeat(indent) + currentLine.trim());
        currentLine = word + ' ';
      } else {
        currentLine += word + ' ';
      }
    });

    if (currentLine) {
      lines.push(' '.repeat(indent) + currentLine.trim());
    }

    return lines.join('\n');
  }

  private centerText(text: string, width: number): string {
    const padding = width - text.length;
    const leftPad = Math.floor(padding / 2);
    const rightPad = padding - leftPad;
    return ' '.repeat(leftPad) + text + ' '.repeat(rightPad);
  }

  private formatTime(minutes: number): string {
    if (minutes < 60) {
      return `${Math.round(minutes)}m`;
    }
    const hours = Math.floor(minutes / 60);
    const mins = Math.round(minutes % 60);
    return `${hours}h ${mins}m`;
  }

  private calculateETA(remainingTasks: number, velocity: number): string {
    const remainingHours = remainingTasks / velocity;
    const eta = new Date(Date.now() + remainingHours * 3600000);
    return `${remainingHours.toFixed(1)}h remaining`;
  }

  /**
   * Render progress dashboard
   */
  public renderProgressDashboard(progressData: ProgressMetrics): string {
    const output: string[] = [];

    output.push(this.createBorder('top'));
    output.push(this.createLine(this.centerText('üìä PROGRESS DASHBOARD', this.WIDTH - 4)));
    output.push(this.createBorder('middle'));

    // Overall progress
    const progressBar = this.renderProgressBar(progressData.overallProgress, 40);
    output.push(
      this.createLine(`üìà Overall Progress: ${progressBar} ${progressData.overallProgress}%`),
    );

    // Task summary
    output.push(this.createLine(`‚úÖ Completed: ${progressData.completedTasks || 0}`));
    output.push(this.createLine(`üîÑ In Progress: ${progressData.inProgressTasks || 0}`));
    output.push(this.createLine(`‚è∏ Blocked: ${progressData.blockedTasks || 0}`));
    output.push(this.createLine(`üìä Total: ${progressData.totalTasks || 0}`));

    output.push(this.createBorder('bottom'));

    return output.join('\n');
  }

  /**
   * Render task completion celebration
   */
  public renderTaskCompletion(task: Task): string {
    const output: string[] = [];

    output.push(this.createBorder('top'));
    output.push(this.createLine(this.centerText('üéâ TASK COMPLETED', this.WIDTH - 4)));
    output.push(this.createBorder('middle'));
    output.push(this.createLine(`Task: ${task.title}`));
    output.push(this.createLine(`Progress: 100% ‚úÖ`));
    output.push(this.createBorder('bottom'));

    return output.join('\n');
  }

  /**
   * Render blocker alert
   */
  public renderBlockerAlert(blocker: unknown): string {
    const output: string[] = [];

    output.push(this.createBorder('top'));
    output.push(this.createLine(this.centerText('üö® BLOCKER DETECTED', this.WIDTH - 4)));
    output.push(this.createBorder('middle'));
    output.push(this.createLine(`Issue: ${blocker.title}`));
    output.push(this.createLine(`Severity: ${blocker.severity || 'HIGH'}`));
    output.push(this.createBorder('bottom'));

    return output.join('\n');
  }

  /**
   * Render decision point
   */
  public renderDecisionPoint(decision: unknown): string {
    const output: string[] = [];

    output.push(this.createBorder('top'));
    output.push(this.createLine(this.centerText('ü§î DECISION REQUIRED', this.WIDTH - 4)));
    output.push(this.createBorder('middle'));
    output.push(this.createLine(`Question: ${decision.title}`));
    output.push(this.createBorder('bottom'));

    return output.join('\n');
  }

  /**
   * Visualize SOW
   */
  public visualizeSOW(sow: SOW): string {
    const output: string[] = [];

    output.push(this.createBorder('top'));
    output.push(this.createLine(this.centerText(`üìã ${sow.title}`, this.WIDTH - 4)));
    output.push(this.createBorder('middle'));
    output.push(this.createLine(`Objective: ${sow.objective}`));
    output.push(this.createLine(`Tasks: ${sow.tasks.length}`));
    output.push(this.createBorder('bottom'));

    return output.join('\n');
  }

  /**
   * Visualize tasks
   */
  public visualizeTasks(tasks: Task[]): string {
    const grouped = this.groupTasksByStatus(tasks);
    const output: string[] = [];

    output.push(this.createBorder('top'));
    output.push(this.createLine(this.centerText('üìù TASK BREAKDOWN', this.WIDTH - 4)));
    output.push(this.createBorder('middle'));

    Object.entries(grouped).forEach(([status, statusTasks]) => {
      if (statusTasks.length > 0) {
        const emoji = this.getStatusEmoji(status);
        output.push(
          this.createLine(`${emoji} ${status.toUpperCase()}: ${statusTasks.length} tasks`),
        );
      }
    });

    output.push(this.createBorder('bottom'));

    return output.join('\n');
  }

  /**
   * Visualize progress metrics
   */
  public visualizeProgress(metrics: ProgressMetrics): string {
    return this.renderProgressDashboard(metrics);
  }

  /**
   * Visualize Hourensou report
   */
  public visualizeHourensou(report: unknown): string {
    const output: string[] = [];

    output.push(this.createBorder('top'));
    output.push(this.createLine(this.centerText('üìä HOURENSOU REPORT', this.WIDTH - 4)));
    output.push(this.createBorder('middle'));
    output.push(this.createLine(`Context: ${report.context || 'Active Reporting'}`));
    output.push(this.createBorder('bottom'));

    return output.join('\n');
  }

  /**
   * Render menu options
   */
  public renderMenu(title: string, options: Array<{ value: string; label: string }>): string {
    const output: string[] = [];

    output.push(this.createBorder('top'));
    output.push(this.createLine(this.centerText(title, this.WIDTH - 4)));
    output.push(this.createBorder('middle'));

    options.forEach((option, index) => {
      const prefix = String.fromCharCode(97 + index); // a, b, c...
      output.push(this.createLine(`[${prefix}] ${option.label}`));
    });

    output.push(this.createBorder('bottom'));

    return output.join('\n');
  }

  /**
   * Render confirmation dialog
   */
  public renderConfirmation(question: string, details?: string): string {
    const output: string[] = [];

    output.push(this.createBorder('top'));
    output.push(this.createLine(this.centerText('‚ùì CONFIRMATION', this.WIDTH - 4)));
    output.push(this.createBorder('middle'));
    output.push(this.createLine(question));

    if (details) {
      output.push(this.createLine(details));
    }

    output.push(this.createLine('[Y/n] '));
    output.push(this.createBorder('bottom'));

    return output.join('\n');
  }
}
