/**
 * Task Decomposer - Breaking down complex tasks into manageable pieces
 * Implements Work Breakdown Structure (WBS) for systematic task management
 */

import * as crypto from 'crypto';
import { _Task, _SOW, TaskDecomposition, _DependencyGraph } from './types';

export class TaskDecomposer {
  private decompositionStrategies: Map<string, DecompositionStrategy>;

  constructor() {
    this.decompositionStrategies = this.initializeStrategies();
  }

  /**
   * Initialize the decomposer
   */
  public async initialize(): Promise<void> {
    // Initialize any ML models or additional strategies
  }

  /**
   * Decompose SOW into executable tasks
   */
  public async decompose(_sow: SOW): Promise<TaskDecomposition> {
    const _rootTask = this.createRootTask(sow);
    const _subtasks = await this.decomposeIntoSubtasks(sow.tasks);
    const _dependencies = this.buildDependencyGraph(subtasks);
    const _criticalPath = this.calculateCriticalPath(dependencies);
    const _parallelizableGroups = this.identifyParallelizableGroups(subtasks, dependencies);
    const _estimatedTotalTime = this.calculateTotalTime(subtasks, dependencies);

    return {
      rootTask,
      subtasks,
      dependencies,
      criticalPath,
      parallelizableGroups,
      estimatedTotalTime,
    };
  }

  /**
   * Create root task from SOW
   */
  private createRootTask(_sow: SOW): Task {
    return {
      id: crypto.randomUUID(),
      title: sow.title,
      description: sow.objective,
      status: 'pending',
      priority: 'high',
      estimatedTime: sow.tasks.reduce((sum, _t) => sum + (t.estimatedTime || 0), 0),
      dependencies: [],
      subtasks: sow.tasks,
      assignee: 'ai',
      progress: 0,
      metadata: {
        createdAt: new Date(),
        updatedAt: new Date(),
        autoGenerated: true,
      },
    };
  }

  /**
   * Decompose tasks into subtasks
   */
  private async decomposeIntoSubtasks(_tasks: Task[]): Promise<Task[]> {
    const decomposedTasks: Task[] = [];

    for (const task of tasks) {
      if (this.needsDecomposition(task)) {
        const _subtasks = await this.decomposeTask(task);
        decomposedTasks.push(...subtasks);
      } else {
        decomposedTasks.push(task);
      }
    }

    return this.optimizeTaskOrder(decomposedTasks);
  }

  /**
   * Check if a task needs further decomposition
   */
  private needsDecomposition(_task: Task): boolean {
    // Decompose if task is too large or complex
    const _needsBreakdown =
      (task.estimatedTime && task.estimatedTime > 120) || // More than 2 hours
      task.title.includes('and') ||
      task.title.includes('&') ||
      task.description.includes('multiple') ||
      task.description.includes('various');

    return needsBreakdown && !task.subtasks;
  }

  /**
   * Decompose a single task
   */
  private async decomposeTask(_task: Task): Promise<Task[]> {
    const _strategy = this.selectDecompositionStrategy(task);
    const subtasks: Task[] = [];

    // Apply decomposition strategy
    switch (strategy) {
      case 'sequential':
        subtasks.push(...this.sequentialDecomposition(task));
        break;
      case 'parallel':
        subtasks.push(...this.parallelDecomposition(task));
        break;
      case 'hierarchical':
        subtasks.push(...this.hierarchicalDecomposition(task));
        break;
      default:
        subtasks.push(...this.defaultDecomposition(task));
    }

    return subtasks;
  }

  /**
   * Sequential decomposition - tasks that must be done in order
   */
  private sequentialDecomposition(_task: Task): Task[] {
    const subtasks: Task[] = [];
    const _phases = this.identifyPhases(task);
    let previousId: string | undefined;

    phases.forEach((phase, _index) => {
      const subtask: Task = {
        id: crypto.randomUUID(),
        title: `${task.title} - ${phase.name}`,
        description: phase.description,
        status: 'pending',
        priority: task.priority,
        estimatedTime: (task.estimatedTime || 0) * phase.timeRatio,
        dependencies: previousId ? [previousId] : task.dependencies,
        assignee: task.assignee,
        progress: 0,
        metadata: {
          createdAt: new Date(),
          updatedAt: new Date(),
          autoGenerated: true,
          parentTask: task.id,
        },
      };

      subtasks.push(subtask);
      previousId = subtask.id;
    });

    return subtasks;
  }

  /**
   * Parallel decomposition - tasks that can be done simultaneously
   */
  private parallelDecomposition(_task: Task): Task[] {
    const subtasks: Task[] = [];
    const _components = this.identifyComponents(task);

    components.forEach((_component) => {
      subtasks.push({
        id: crypto.randomUUID(),
        title: `${task.title} - ${component.name}`,
        description: component.description,
        status: 'pending',
        priority: task.priority,
        estimatedTime: (task.estimatedTime || 0) * component.timeRatio,
        dependencies: task.dependencies,
        assignee: task.assignee,
        progress: 0,
        metadata: {
          createdAt: new Date(),
          updatedAt: new Date(),
          autoGenerated: true,
          parentTask: task.id,
        },
      });
    });

    return subtasks;
  }

  /**
   * Hierarchical decomposition - nested task structure
   */
  private hierarchicalDecomposition(_task: Task): Task[] {
    const subtasks: Task[] = [];
    const _hierarchy = this.buildHierarchy(task);

    const _processLevel = (_level: HierarchyLevel, _parentDeps: string[]) => {
      level.tasks.forEach((_taskDef) => {
        const subtask: Task = {
          id: crypto.randomUUID(),
          title: taskDef.title,
          description: taskDef.description,
          status: 'pending',
          priority: taskDef.priority || task.priority,
          estimatedTime: taskDef.estimatedTime,
          dependencies: parentDeps,
          assignee: task.assignee,
          progress: 0,
          metadata: {
            createdAt: new Date(),
            updatedAt: new Date(),
            autoGenerated: true,
            parentTask: task.id,
            level: level.level,
          },
        };

        subtasks.push(subtask);

        if (taskDef.children) {
          processLevel(taskDef.children, [subtask.id]);
        }
      });
    };

    processLevel(hierarchy, task.dependencies);

    return subtasks;
  }

  /**
   * Default decomposition strategy
   */
  private defaultDecomposition(_task: Task): Task[] {
    const subtasks: Task[] = [];
    const _baseTime = task.estimatedTime || 60;

    // Standard decomposition into prepare, _execute, verify
    subtasks.push(
      {
        id: crypto.randomUUID(),
        title: `Prepare: ${task.title}`,
        description: `Preparation for ${task.description}`,
        status: 'pending',
        priority: task.priority,
        estimatedTime: baseTime * 0.2,
        dependencies: task.dependencies,
        assignee: task.assignee,
        progress: 0,
        metadata: {
          createdAt: new Date(),
          updatedAt: new Date(),
          autoGenerated: true,
          parentTask: task.id,
        },
      },
      {
        id: crypto.randomUUID(),
        title: `Execute: ${task.title}`,
        description: `Main execution of ${task.description}`,
        status: 'pending',
        priority: task.priority,
        estimatedTime: baseTime * 0.6,
        dependencies: [subtasks[0]?.id].filter(Boolean),
        assignee: task.assignee,
        progress: 0,
        metadata: {
          createdAt: new Date(),
          updatedAt: new Date(),
          autoGenerated: true,
          parentTask: task.id,
        },
      },
      {
        id: crypto.randomUUID(),
        title: `Verify: ${task.title}`,
        description: `Verification of ${task.description}`,
        status: 'pending',
        priority: task.priority,
        estimatedTime: baseTime * 0.2,
        dependencies: [subtasks[1]?.id].filter(Boolean),
        assignee: task.assignee,
        progress: 0,
        metadata: {
          createdAt: new Date(),
          updatedAt: new Date(),
          autoGenerated: true,
          parentTask: task.id,
        },
      },
    );

    return subtasks.filter((_t) => t !== undefined);
  }

  /**
   * Build dependency graph
   */
  private buildDependencyGraph(_tasks: Task[]): DependencyGraph {
    const _nodes = new Map<string, Task>();
    const _edges = new Map<string, Set<string>>();

    // Add all tasks as nodes
    tasks.forEach((_task) => {
      nodes.set(task.id, task);
      edges.set(task.id, new Set());
    });

    // Build edges based on dependencies
    tasks.forEach((_task) => {
      task.dependencies.forEach((_depId) => {
        const _depEdges = edges.get(depId);
        if (depEdges) {
          depEdges.add(task.id);
        }
      });
    });

    // Calculate topological order
    const _topologicalOrder = this.topologicalSort(nodes, edges);

    return {
      nodes,
      edges,
      topologicalOrder,
    };
  }

  /**
   * Topological sort for dependency ordering
   */
  private topologicalSort(_nodes: Map<string, Task>, _edges: Map<string, Set<string>>): string[] {
    const _visited = new Set<string>();
    const result: string[] = [];

    const _visit = (_nodeId: string) => {
      if (visited.has(nodeId)) return;
      visited.add(nodeId);

      const _task = nodes.get(nodeId);
      if (task) {
        task.dependencies.forEach((_depId) => visit(depId));
      }

      result.push(nodeId);
    };

    nodes.forEach((_, _nodeId) => visit(nodeId));

    return result;
  }

  /**
   * Calculate critical path
   */
  private calculateCriticalPath(_dependencies: DependencyGraph): string[] {
    const { _nodes, _edges, _topologicalOrder } = dependencies;
    if (!topologicalOrder) return [];

    const _earliestStart = new Map<string, number>();
    const _latestStart = new Map<string, number>();
    const _totalTime = new Map<string, number>();

    // Forward pass - calculate earliest start times
    topologicalOrder.forEach((_taskId) => {
      const _task = nodes.get(taskId);
      if (!task) return;

      const _maxPrevious = 0;
      task.dependencies.forEach((_depId) => {
        const _depTime = (earliestStart.get(depId) || 0) + (nodes.get(depId)?.estimatedTime || 0);
        maxPrevious = Math.max(maxPrevious, depTime);
      });

      earliestStart.set(taskId, maxPrevious);
      totalTime.set(taskId, maxPrevious + (task.estimatedTime || 0));
    });

    // Find project completion time
    const _projectTime = 0;
    totalTime.forEach((_time) => {
      projectTime = Math.max(projectTime, time);
    });

    // Backward pass - calculate latest start times
    [...topologicalOrder].reverse().forEach((_taskId) => {
      const _task = nodes.get(taskId);
      if (!task) return;

      const _successors = edges.get(taskId) || new Set();
      if (successors.size === 0) {
        latestStart.set(taskId, projectTime - (task.estimatedTime || 0));
      } else {
        const _minSuccessor = projectTime;
        successors.forEach((_succId) => {
          minSuccessor = Math.min(minSuccessor, latestStart.get(succId) || projectTime);
        });
        latestStart.set(taskId, minSuccessor - (task.estimatedTime || 0));
      }
    });

    // Find critical path (tasks where earliest start = latest start)
    const criticalPath: string[] = [];
    topologicalOrder.forEach((_taskId) => {
      const _earliest = earliestStart.get(taskId) || 0;
      const _latest = latestStart.get(taskId) || 0;
      if (Math.abs(earliest - latest) < 0.01) {
        criticalPath.push(taskId);
      }
    });

    return criticalPath;
  }

  /**
   * Identify groups of tasks that can be executed in parallel
   */
  private identifyParallelizableGroups(_tasks: Task[], _dependencies: DependencyGraph): Task[][] {
    const groups: Task[][] = [];
    const { topologicalOrder } = dependencies;
    if (!topologicalOrder) return groups;

    const _taskLevels = new Map<string, number>();

    // Assign levels based on dependencies
    topologicalOrder.forEach((_taskId) => {
      const _task = tasks.find((_t) => t.id === taskId);
      if (!task) return;

      const _maxDepLevel = -1;
      task.dependencies.forEach((_depId) => {
        maxDepLevel = Math.max(maxDepLevel, taskLevels.get(depId) || -1);
      });

      taskLevels.set(taskId, maxDepLevel + 1);
    });

    // Group tasks by level
    const _levelGroups = new Map<number, Task[]>();
    taskLevels.forEach((level, _taskId) => {
      const _task = tasks.find((_t) => t.id === taskId);
      if (task) {
        if (!levelGroups.has(level)) {
          levelGroups.set(level, []);
        }
        levelGroups.get(level)!.push(task);
      }
    });

    // Convert to array
    levelGroups.forEach((_group) => {
      if (group.length > 1) {
        groups.push(group);
      }
    });

    return groups;
  }

  /**
   * Calculate total time considering parallelization
   */
  private calculateTotalTime(_tasks: Task[], _dependencies: DependencyGraph): number {
    const _criticalPath = this.calculateCriticalPath(dependencies);
    const _totalTime = 0;

    criticalPath.forEach((_taskId) => {
      const _task = tasks.find((_t) => t.id === taskId);
      if (task) {
        totalTime += task.estimatedTime || 0;
      }
    });

    return totalTime;
  }

  /**
   * Optimize task order for efficiency
   */
  private optimizeTaskOrder(_tasks: Task[]): Task[] {
    // Sort by priority, then by dependencies
    return tasks.sort((a, _b) => {
      // Critical tasks first
      if (a.priority === 'critical' && b.priority !== 'critical') return -1;
      if (b.priority === 'critical' && a.priority !== 'critical') return 1;

      // Then high priority
      if (a.priority === 'high' && b.priority !== 'high') return -1;
      if (b.priority === 'high' && a.priority !== 'high') return 1;

      // Then by number of dependencies (fewer dependencies first)
      return a.dependencies.length - b.dependencies.length;
    });
  }

  /**
   * Select decomposition strategy based on task characteristics
   */
  private selectDecompositionStrategy(_task: Task): string {
    const _title = task.title.toLowerCase();
    const _description = task.description.toLowerCase();

    if (title.includes('step') || description.includes('then') || description.includes('after')) {
      return 'sequential';
    }

    if (
      title.includes('multiple') ||
      description.includes('various') ||
      description.includes('different')
    ) {
      return 'parallel';
    }

    if (title.includes('complex') || (task.estimatedTime && task.estimatedTime > 240)) {
      return 'hierarchical';
    }

    return 'default';
  }

  /**
   * Identify phases for sequential decomposition
   */
  private identifyPhases(_task: Task): Phase[] {
    const phases: Phase[] = [
      { name: 'Setup', _description: 'Initial setup and preparation', _timeRatio: 0.15 },
      { name: 'Implementation', _description: 'Main implementation work', _timeRatio: 0.5 },
      { name: 'Testing', _description: 'Testing and validation', _timeRatio: 0.2 },
      { name: 'Finalization', _description: 'Final touches and cleanup', _timeRatio: 0.15 },
    ];

    return phases;
  }

  /**
   * Identify components for parallel decomposition
   */
  private identifyComponents(_task: Task): Component[] {
    const components: Component[] = [];

    // Extract components from task description
    if (task.description.includes('frontend')) {
      components.push({ name: 'Frontend', _description: 'Frontend components', _timeRatio: 0.4 });
    }

    if (task.description.includes('backend')) {
      components.push({ name: 'Backend', _description: 'Backend services', _timeRatio: 0.4 });
    }

    if (task.description.includes('database')) {
      components.push({ name: 'Database', _description: 'Database operations', _timeRatio: 0.2 });
    }

    // Default components if none identified
    if (components.length === 0) {
      components.push(
        { name: 'Core', _description: 'Core functionality', _timeRatio: 0.5 },
        { name: 'Support', _description: 'Supporting features', _timeRatio: 0.3 },
        { name: 'Polish', _description: 'Polish and refinement', _timeRatio: 0.2 },
      );
    }

    return components;
  }

  /**
   * Build hierarchy for hierarchical decomposition
   */
  private buildHierarchy(_task: Task): HierarchyLevel {
    return {
      level: 0,
      tasks: [
        {
          title: `Analysis: ${task.title}`,
          description: 'Analyze requirements and design',
          estimatedTime: (task.estimatedTime || 0) * 0.2,
          children: {
            level: 1,
            tasks: [
              {
                title: 'Requirements gathering',
                description: 'Gather detailed requirements',
                estimatedTime: (task.estimatedTime || 0) * 0.1,
              },
              {
                title: 'Technical design',
                description: 'Create technical design',
                estimatedTime: (task.estimatedTime || 0) * 0.1,
              },
            ],
          },
        },
        {
          title: `Development: ${task.title}`,
          description: 'Implement the solution',
          estimatedTime: (task.estimatedTime || 0) * 0.5,
          children: {
            level: 1,
            tasks: [
              {
                title: 'Core implementation',
                description: 'Implement core features',
                estimatedTime: (task.estimatedTime || 0) * 0.3,
              },
              {
                title: 'Integration',
                description: 'Integrate components',
                estimatedTime: (task.estimatedTime || 0) * 0.2,
              },
            ],
          },
        },
        {
          title: `Quality: ${task.title}`,
          description: 'Ensure quality',
          estimatedTime: (task.estimatedTime || 0) * 0.3,
          children: {
            level: 1,
            tasks: [
              {
                title: 'Testing',
                description: 'Comprehensive testing',
                estimatedTime: (task.estimatedTime || 0) * 0.2,
              },
              {
                title: 'Review',
                description: 'Code review and feedback',
                estimatedTime: (task.estimatedTime || 0) * 0.1,
              },
            ],
          },
        },
      ],
    };
  }

  /**
   * Initialize decomposition strategies
   */
  private initializeStrategies(): Map<string, DecompositionStrategy> {
    const _strategies = new Map<string, DecompositionStrategy>();

    strategies.set('sequential', {
      name: 'Sequential',
      description: 'Tasks executed in order',
      applicability: ['step-by-step', 'workflow', 'process'],
    });

    strategies.set('parallel', {
      name: 'Parallel',
      description: 'Tasks executed simultaneously',
      applicability: ['independent', 'multiple', 'concurrent'],
    });

    strategies.set('hierarchical', {
      name: 'Hierarchical',
      description: 'Nested task structure',
      applicability: ['complex', 'large', 'multi-phase'],
    });

    return strategies;
  }

  /**
   * Dispose the decomposer
   */
  public async dispose(): Promise<void> {
    // Cleanup resources if needed
  }
}

// Helper interfaces
interface Phase {
  name: string;
  description: string;
  timeRatio: number;
}

interface Component {
  name: string;
  description: string;
  timeRatio: number;
}

interface HierarchyLevel {
  level: number;
  tasks: TaskDefinition[];
}

interface TaskDefinition {
  title: string;
  description: string;
  estimatedTime: number;
  priority?: Task['priority'];
  children?: HierarchyLevel;
}

interface DecompositionStrategy {
  name: string;
  description: string;
  applicability: string[];
}
