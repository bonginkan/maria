/**
 * SOW Generator - Automatic Statement of Work generation
 * Creates structured SOWs from user intents to enforce planning discipline
 */

import * as crypto from 'crypto';
import {
  SOW,
  IntentAnalysis,
  Task,
  Deliverable,
  Timeline,
  Milestone,
  Phase,
  Risk,
  TaskDecomposition,
} from './types';

export class SOWGenerator {
  private templates: Map<string, SOWTemplate>;
  private riskMitigations: Map<string, string>;

  constructor() {
    this.templates = this.initializeTemplates();
    this.riskMitigations = this.initializeRiskMitigations();
  }

  /**
   * Initialize the generator
   */
  public async initialize(): Promise<void> {
    // Load any additional templates or configurations
  }

  /**
   * Generate SOW from intent analysis
   */
  public async generate(intent: IntentAnalysis, request: string): Promise<SOW> {
    const template = this.getTemplate(intent.primaryIntent);
    const tasks = this.generateTasks(intent, request);
    const deliverables = this.generateDeliverables(intent, tasks);
    const timeline = this.generateTimeline(tasks, deliverables);
    const risks = this.generateRisks(intent);
    const assumptions = this.generateAssumptions(intent);
    const successCriteria = this.generateSuccessCriteria(intent, deliverables);

    const sow: SOW = {
      id: crypto.randomUUID(),
      title: this.generateTitle(intent, request),
      objective: this.generateObjective(intent, request),
      scope: this.generateScope(intent, request),
      deliverables,
      timeline,
      risks,
      assumptions,
      successCriteria,
      tasks,
      approvalStatus: 'draft',
      version: '1.0.0',
    };

    return sow;
  }

  /**
   * Create SOW from task decomposition
   */
  public async createFromDecomposition(decomposition: TaskDecomposition): Promise<SOW> {
    const deliverables = this.extractDeliverablesFromTasks(decomposition.subtasks);
    const timeline = this.generateTimelineFromTasks(decomposition.subtasks);
    const risks = this.extractRisksFromTasks(decomposition.subtasks);

    return {
      id: crypto.randomUUID(),
      title: decomposition.rootTask.title,
      objective: decomposition.rootTask.description,
      scope: this.extractScopeFromTasks(decomposition.subtasks),
      deliverables,
      timeline,
      risks,
      assumptions: ['All dependencies are available', 'No external blockers'],
      successCriteria: ['All tasks completed successfully', 'No critical issues remaining'],
      tasks: decomposition.subtasks,
      approvalStatus: 'approved',
      version: '1.0.0',
    };
  }

  /**
   * Generate title for SOW
   */
  private generateTitle(intent: IntentAnalysis, request: string): string {
    const action = this.getActionFromIntent(intent.primaryIntent);
    const subject = this.extractSubject(request);

    return `${action}: ${subject}`;
  }

  /**
   * Generate objective statement
   */
  private generateObjective(intent: IntentAnalysis, request: string): string {
    const complexity = intent.estimatedComplexity;
    const approach = intent.suggestedApproach;

    let objective = `To ${this.getActionFromIntent(intent.primaryIntent).toLowerCase()} `;
    objective += `${this.extractSubject(request).toLowerCase()} `;
    objective += `using ${approach}. `;

    if (intent.secondaryIntents.length > 0) {
      objective += `This includes ${intent.secondaryIntents.join(', ')}.`;
    }

    return objective;
  }

  /**
   * Generate scope statements
   */
  private generateScope(intent: IntentAnalysis, request: string): string[] {
    const scope: string[] = [];

    // Primary scope
    scope.push(`Primary: ${this.getActionFromIntent(intent.primaryIntent)} implementation`);

    // Secondary scope items
    intent.secondaryIntents.forEach((secondary) => {
      scope.push(`Secondary: ${this.formatSecondaryIntent(secondary)}`);
    });

    // Implicit requirements as scope
    intent.implicitRequirements.forEach((req) => {
      scope.push(`Requirement: ${this.formatRequirement(req)}`);
    });

    // Out of scope (important for clarity)
    scope.push('Out of scope: Any work not explicitly mentioned in this SOW');

    return scope;
  }

  /**
   * Generate tasks based on intent
   */
  private generateTasks(intent: IntentAnalysis, request: string): Task[] {
    const tasks: Task[] = [];
    const baseTime = this.estimateBaseTime(intent.estimatedComplexity);

    // Planning phase tasks
    tasks.push(
      this.createTask(
        'Requirements Analysis',
        'Analyze and document detailed requirements',
        'pending',
        'high',
        baseTime * 0.1,
        [],
      ),
    );

    tasks.push(
      this.createTask(
        'Technical Design',
        'Create technical design and architecture',
        'pending',
        'high',
        baseTime * 0.15,
        [tasks[0].id],
      ),
    );

    // Implementation phase tasks
    const implementationTasks = this.generateImplementationTasks(intent, baseTime);
    implementationTasks.forEach((task) => {
      task.dependencies = [tasks[1].id]; // Depend on design
      tasks.push(task);
    });

    // Testing phase tasks
    if (intent.secondaryIntents.includes('testing_required')) {
      tasks.push(
        this.createTask(
          'Unit Testing',
          'Write and execute unit tests',
          'pending',
          'high',
          baseTime * 0.15,
          implementationTasks.map((t) => t.id),
        ),
      );

      tasks.push(
        this.createTask(
          'Integration Testing',
          'Perform integration testing',
          'pending',
          'medium',
          baseTime * 0.1,
          [tasks[tasks.length - 1].id],
        ),
      );
    }

    // Documentation phase tasks
    if (intent.secondaryIntents.includes('documentation_needed')) {
      tasks.push(
        this.createTask(
          'Documentation',
          'Create user and technical documentation',
          'pending',
          'medium',
          baseTime * 0.1,
          implementationTasks.map((t) => t.id),
        ),
      );
    }

    // Review and deployment
    tasks.push(
      this.createTask(
        'Code Review',
        'Conduct thorough code review',
        'pending',
        'high',
        baseTime * 0.05,
        implementationTasks.map((t) => t.id),
      ),
    );

    if (intent.secondaryIntents.includes('deployment_consideration')) {
      tasks.push(
        this.createTask(
          'Deployment Preparation',
          'Prepare for deployment',
          'pending',
          'critical',
          baseTime * 0.1,
          [tasks[tasks.length - 1].id],
        ),
      );
    }

    return tasks;
  }

  /**
   * Generate implementation-specific tasks
   */
  private generateImplementationTasks(intent: IntentAnalysis, baseTime: number): Task[] {
    const tasks: Task[] = [];

    switch (intent.primaryIntent) {
      case 'implement_feature':
        tasks.push(
          this.createTask(
            'Core Implementation',
            'Implement core functionality',
            'pending',
            'critical',
            baseTime * 0.3,
          ),
          this.createTask(
            'UI Development',
            'Create user interface',
            'pending',
            'high',
            baseTime * 0.2,
          ),
          this.createTask(
            'API Integration',
            'Integrate with backend APIs',
            'pending',
            'high',
            baseTime * 0.15,
          ),
        );
        break;

      case 'fix_bug':
        tasks.push(
          this.createTask(
            'Bug Reproduction',
            'Reproduce and isolate bug',
            'pending',
            'critical',
            baseTime * 0.2,
          ),
          this.createTask(
            'Root Cause Analysis',
            'Identify root cause',
            'pending',
            'critical',
            baseTime * 0.2,
          ),
          this.createTask(
            'Fix Implementation',
            'Implement bug fix',
            'pending',
            'critical',
            baseTime * 0.15,
          ),
          this.createTask(
            'Regression Testing',
            'Test for regressions',
            'pending',
            'high',
            baseTime * 0.1,
          ),
        );
        break;

      case 'refactor_code':
        tasks.push(
          this.createTask(
            'Code Analysis',
            'Analyze existing code structure',
            'pending',
            'high',
            baseTime * 0.15,
          ),
          this.createTask(
            'Refactoring Plan',
            'Create refactoring plan',
            'pending',
            'high',
            baseTime * 0.1,
          ),
          this.createTask(
            'Refactoring Implementation',
            'Implement refactoring',
            'pending',
            'high',
            baseTime * 0.3,
          ),
          this.createTask(
            'Verification',
            'Verify functionality preserved',
            'pending',
            'critical',
            baseTime * 0.1,
          ),
        );
        break;

      default:
        tasks.push(
          this.createTask(
            'Implementation',
            'Main implementation work',
            'pending',
            'high',
            baseTime * 0.5,
          ),
          this.createTask('Testing', 'Test implementation', 'pending', 'high', baseTime * 0.15),
        );
    }

    return tasks;
  }

  /**
   * Create a single task
   */
  private createTask(
    title: string,
    description: string,
    status: Task['status'],
    priority: Task['priority'],
    estimatedTime: number,
    dependencies: string[] = [],
  ): Task {
    return {
      id: crypto.randomUUID(),
      title,
      description,
      status,
      priority,
      estimatedTime,
      dependencies,
      assignee: 'ai',
      progress: 0,
      metadata: {
        createdAt: new Date(),
        updatedAt: new Date(),
        autoGenerated: true,
      },
    };
  }

  /**
   * Generate deliverables
   */
  private generateDeliverables(intent: IntentAnalysis, tasks: Task[]): Deliverable[] {
    const deliverables: Deliverable[] = [];

    // Code deliverable
    deliverables.push({
      id: crypto.randomUUID(),
      name: 'Source Code',
      description: 'Complete, tested, and documented source code',
      acceptanceCriteria: [
        'Code passes all tests',
        'Code follows style guidelines',
        'No critical issues or bugs',
        'Performance requirements met',
      ],
      estimatedEffort: tasks.reduce((sum, t) => sum + (t.estimatedTime || 0), 0) / 60,
    });

    // Documentation deliverable
    if (intent.secondaryIntents.includes('documentation_needed')) {
      deliverables.push({
        id: crypto.randomUUID(),
        name: 'Documentation',
        description: 'Comprehensive documentation',
        acceptanceCriteria: [
          'API documentation complete',
          'User guide created',
          'Code comments added',
        ],
        estimatedEffort: 2,
      });
    }

    // Test deliverable
    if (intent.secondaryIntents.includes('testing_required')) {
      deliverables.push({
        id: crypto.randomUUID(),
        name: 'Test Suite',
        description: 'Complete test suite with coverage',
        acceptanceCriteria: [
          'Unit tests > 80% coverage',
          'Integration tests passing',
          'No failing tests',
        ],
        estimatedEffort: 3,
      });
    }

    return deliverables;
  }

  /**
   * Generate timeline
   */
  private generateTimeline(tasks: Task[], deliverables: Deliverable[]): Timeline {
    const totalHours = tasks.reduce((sum, t) => sum + (t.estimatedTime || 0), 0) / 60;
    const startDate = new Date();
    const endDate = new Date(startDate.getTime() + totalHours * 60 * 60 * 1000);

    const milestones: Milestone[] = [
      {
        id: crypto.randomUUID(),
        name: 'Planning Complete',
        date: new Date(startDate.getTime() + totalHours * 0.2 * 60 * 60 * 1000),
        deliverables: [],
        status: 'pending',
      },
      {
        id: crypto.randomUUID(),
        name: 'Implementation Complete',
        date: new Date(startDate.getTime() + totalHours * 0.7 * 60 * 60 * 1000),
        deliverables: [deliverables[0]?.id].filter(Boolean),
        status: 'pending',
      },
      {
        id: crypto.randomUUID(),
        name: 'Project Complete',
        date: endDate,
        deliverables: deliverables.map((d) => d.id),
        status: 'pending',
      },
    ];

    const phases: Phase[] = [
      {
        id: crypto.randomUUID(),
        name: 'Planning',
        startDate,
        endDate: milestones[0].date,
        tasks: tasks.slice(0, 2).map((t) => t.id),
        status: 'not_started',
      },
      {
        id: crypto.randomUUID(),
        name: 'Implementation',
        startDate: milestones[0].date,
        endDate: milestones[1].date,
        tasks: tasks.slice(2, -2).map((t) => t.id),
        status: 'not_started',
      },
      {
        id: crypto.randomUUID(),
        name: 'Finalization',
        startDate: milestones[1].date,
        endDate,
        tasks: tasks.slice(-2).map((t) => t.id),
        status: 'not_started',
      },
    ];

    return {
      startDate,
      endDate,
      milestones,
      phases,
    };
  }

  /**
   * Generate risks
   */
  private generateRisks(intent: IntentAnalysis): Risk[] {
    const risks: Risk[] = [];

    (intent.identifiedRisks || []).forEach((riskId) => {
      const mitigation =
        this.riskMitigations.get(riskId) || 'Implement standard mitigation procedures';

      risks.push({
        id: crypto.randomUUID(),
        description: this.formatRisk(riskId),
        impact: this.assessRiskImpact(riskId),
        probability: this.assessRiskProbability(intent.estimatedComplexity),
        mitigation,
        owner: 'ai',
      });
    });

    // Add default risks based on complexity
    if (intent.estimatedComplexity === 'complex' || intent.estimatedComplexity === 'very_complex') {
      risks.push({
        id: crypto.randomUUID(),
        description: 'Timeline overrun due to unexpected complexity',
        impact: 'high',
        probability: 'medium',
        mitigation: 'Regular progress monitoring and early escalation',
        owner: 'ai',
      });
    }

    return risks;
  }

  /**
   * Generate assumptions
   */
  private generateAssumptions(intent: IntentAnalysis): string[] {
    const assumptions: string[] = [
      'All required dependencies and libraries are available',
      'Development environment is properly configured',
      'No external blockers or dependencies',
    ];

    if (intent.requiredCapabilities?.includes('api_design')) {
      assumptions.push('API endpoints are accessible and documented');
    }

    if (intent.requiredCapabilities?.includes('database_management')) {
      assumptions.push('Database access and credentials are provided');
    }

    if (intent.secondaryIntents.includes('deployment_consideration')) {
      assumptions.push('Deployment infrastructure is ready');
    }

    return assumptions;
  }

  /**
   * Generate success criteria
   */
  private generateSuccessCriteria(intent: IntentAnalysis, deliverables: Deliverable[]): string[] {
    const criteria: string[] = [];

    // General criteria
    criteria.push('All deliverables completed and accepted');
    criteria.push('All tasks marked as completed');
    criteria.push('No critical bugs or issues remaining');

    // Intent-specific criteria
    switch (intent.primaryIntent) {
      case 'implement_feature':
        criteria.push('Feature working as specified');
        criteria.push('User acceptance testing passed');
        break;
      case 'fix_bug':
        criteria.push('Bug no longer reproducible');
        criteria.push('No regression issues introduced');
        break;
      case 'refactor_code':
        criteria.push('Code quality metrics improved');
        criteria.push('All existing functionality preserved');
        break;
    }

    // Quality criteria
    if (intent.implicitRequirements.includes('code_quality_standards')) {
      criteria.push('Code review approved');
      criteria.push('Coding standards met');
    }

    if (intent.secondaryIntents.includes('testing_required')) {
      criteria.push('Test coverage > 80%');
      criteria.push('All tests passing');
    }

    return criteria;
  }

  // Helper methods

  private getTemplate(intent: string): SOWTemplate {
    return this.templates.get(intent) || this.templates.get('default')!;
  }

  private getActionFromIntent(intent: string): string {
    const actionMap: Record<string, string> = {
      implement_feature: 'Feature Implementation',
      fix_bug: 'Bug Fix',
      refactor_code: 'Code Refactoring',
      create_documentation: 'Documentation Creation',
      write_tests: 'Test Development',
      analyze_code: 'Code Analysis',
      optimize_performance: 'Performance Optimization',
      integrate_system: 'System Integration',
      deploy_application: 'Application Deployment',
      configure_system: 'System Configuration',
      general_development: 'Development Work',
    };

    return actionMap[intent] || 'Development Task';
  }

  private extractSubject(request: string): string {
    // Simple extraction - in production, use NLP
    const words = request.split(' ').slice(0, 10);
    return words.join(' ');
  }

  private formatSecondaryIntent(intent: string): string {
    return intent.replace(/_/g, ' ').replace(/\b\w/g, (c) => c.toUpperCase());
  }

  private formatRequirement(requirement: string): string {
    return requirement.replace(/_/g, ' ').replace(/\b\w/g, (c) => c.toUpperCase());
  }

  private formatRisk(riskId: string): string {
    return riskId.replace(/_/g, ' ').replace(/\b\w/g, (c) => c.toUpperCase());
  }

  private estimateBaseTime(complexity: string): number {
    const timeMap: Record<string, number> = {
      simple: 120, // 2 hours
      moderate: 240, // 4 hours
      complex: 480, // 8 hours
      very_complex: 960, // 16 hours
    };

    return timeMap[complexity] || 240;
  }

  private assessRiskImpact(riskId: string): 'low' | 'medium' | 'high' | 'critical' {
    if (riskId.includes('production') || riskId.includes('security')) return 'critical';
    if (riskId.includes('data') || riskId.includes('performance')) return 'high';
    if (riskId.includes('integration') || riskId.includes('migration')) return 'medium';
    return 'low';
  }

  private assessRiskProbability(complexity: string): 'low' | 'medium' | 'high' {
    if (complexity === 'very_complex') return 'high';
    if (complexity === 'complex') return 'medium';
    return 'low';
  }

  private extractDeliverablesFromTasks(tasks: Task[]): Deliverable[] {
    // Group tasks into deliverables
    return [
      {
        id: crypto.randomUUID(),
        name: 'Completed Implementation',
        description: 'All tasks completed successfully',
        acceptanceCriteria: ['All tasks marked as done'],
        estimatedEffort: tasks.reduce((sum, t) => sum + (t.estimatedTime || 0), 0) / 60,
      },
    ];
  }

  private generateTimelineFromTasks(tasks: Task[]): Timeline {
    const totalTime = tasks.reduce((sum, t) => sum + (t.estimatedTime || 0), 0);
    const startDate = new Date();
    const endDate = new Date(startDate.getTime() + totalTime * 60 * 1000);

    return {
      startDate,
      endDate,
      milestones: [],
      phases: [],
    };
  }

  private extractRisksFromTasks(tasks: Task[]): Risk[] {
    return [];
  }

  private extractScopeFromTasks(tasks: Task[]): string[] {
    return tasks.map((t) => t.title);
  }

  private initializeTemplates(): Map<string, SOWTemplate> {
    const templates = new Map<string, SOWTemplate>();

    // Define templates for different intent types
    templates.set('default', {
      sections: [
        'objective',
        'scope',
        'deliverables',
        'timeline',
        'risks',
        'assumptions',
        'success_criteria',
      ],
    });

    return templates;
  }

  private initializeRiskMitigations(): Map<string, string> {
    const mitigations = new Map<string, string>();

    mitigations.set('production_deployment_risk', 'Implement staged rollout with rollback plan');
    mitigations.set('data_integrity_risk', 'Create backups and implement transaction logging');
    mitigations.set(
      'security_vulnerability_risk',
      'Conduct security audit and penetration testing',
    );
    mitigations.set(
      'performance_degradation_risk',
      'Implement performance monitoring and optimization',
    );
    mitigations.set('migration_failure_risk', 'Create rollback procedures and test in staging');
    mitigations.set(
      'integration_compatibility_risk',
      'Perform compatibility testing and versioning',
    );
    mitigations.set('regression_risk', 'Implement comprehensive regression test suite');
    mitigations.set('scope_creep_risk', 'Strict change control and regular reviews');
    mitigations.set('timeline_overrun_risk', 'Buffer time and parallel task execution');

    return mitigations;
  }
}

interface SOWTemplate {
  sections: string[];
}
