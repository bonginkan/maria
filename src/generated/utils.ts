/**
 * Create a simple hello world function
 * Generated by MARIA CODE with functional programming best practices
 */

// Types
type Result<T, E = Error> =
  | {
      success: true;
      data: T;
    }
  | {
      success: false;
      error: E;
    };

type AsyncResult<T, E = Error> = Promise<Result<T, E>>;

interface ProcessingOptions {
  timeout?: number;
  retries?: number;
  cache?: boolean;
  validate?: boolean;
}

// Utility functions
const createResult = <T>(data: T): Result<T> => ({
  success: true as const,
  data,
});

const createError = <E = Error>(error: E): Result<never, E> => ({
  success: false as const,
  error,
});

// Main processing function
export const processData = async (
  input: unknown,
  options: ProcessingOptions = {},
): AsyncResult<unknown> => {
  try {
    // Input validation
    if (!input) {
      return createError(new Error('Input is required'));
    }

    // Apply default options
    const config = {
      timeout: 5000,
      retries: 3,
      cache: true,
      validate: true,
      ...options,
    };

    // Validation phase
    if (config.validate) {
      const validationResult = await validateInput(input);
      if (!validationResult.success) {
        return createError(new Error(`Validation failed: ${validationResult.error}`));
      }
    }

    // Processing with timeout
    const processWithTimeout = new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        reject(new Error('Processing timeout'));
      }, config.timeout);

      // Main processing logic
      performProcessing(input)
        .then((result) => {
          clearTimeout(timer);
          resolve(result);
        })
        .catch((error) => {
          clearTimeout(timer);
          reject(error);
        });
    });

    const result = await processWithTimeout;

    return createResult({
      input,
      output: result,
      timestamp: Date.now(),
      config,
    });
  } catch (error) {
    console.error('Processing error:', error);
    return createError(error as Error);
  }
};

// Helper functions
const validateInput = async (input: unknown) => {
  try {
    // Add your validation logic here
    if (typeof input === 'object' && input !== null) {
      return createResult(true);
    }
    return createError(new Error('Input must be an object'));
  } catch (error) {
    return createError(error as Error);
  }
};

const performProcessing = async (input: unknown) => {
  // Simulate complex processing
  await new Promise((resolve) => setTimeout(resolve, 100));
  // Transform input
  const processed = {
    original: input,
    processed: true,
    timestamp: Date.now(),
    hash: generateHash(JSON.stringify(input)),
  };

  return processed;
};

const generateHash = (str: string) => {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash.toString(36);
};

// Utility functions for common operations
export const retry = async <T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  delay: number = 1000,
): Promise<T> => {
  let lastError: Error = new Error('Max retries exceeded');

  for (let i = 0; i <= maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      if (i < maxRetries) {
        await new Promise((resolve) => setTimeout(resolve, delay * Math.pow(2, i)));
      }
    }
  }

  throw lastError;
};

export const memoize = <T extends (...args: unknown[]) => unknown>(fn: T) => {
  const cache = new Map();

  return ((...args: Parameters<T>) => {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      return cache.get(key);
    }

    const result = fn(...args);
    cache.set(key, result);

    return result;
  }) as T;
};

export const debounce = <T extends (...args: unknown[]) => unknown>(fn: T, delay: number) => {
  let timeoutId: NodeJS.Timeout | undefined;

  return ((...args: Parameters<T>) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  }) as (...args: Parameters<T>) => void;
};

// Export all utilities
export default {
  processData,
  retry,
  memoize,
  debounce,
  createResult,
  createError,
};
