#!/usr/bin/env node

/**
 * MARIA CODE - Interactive CLI with Interrupt Feature
 * Clean, minimal design with interrupt capability
 */

import readline from 'readline';
import chalk from 'chalk';
import figlet from 'figlet';
import { execSync } from 'child_process';

class MariaCLI {
  constructor() {
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: chalk.gray('> ')
    });
    
    this.conversationContext = [];
    this.currentLanguage = 'en';
    this.currentProcessing = null;
    this.processingTimeout = null;
    this.isProcessing = false;
    this.interruptQueue = [];
    
    this.commands = {
      '/help': 'Show all 40 available commands',
      '/code': 'AI code generation',
      '/test': 'AI-powered test generation',
      '/review': 'Code review',
      '/init': 'Generate MARIA.md design document',
      '/status': 'Display system status',
      '/model': 'Select AI model',
      '/config': 'Configuration panel',
      '/video': 'AI video generation',
      '/image': 'AI image generation',
      '/build': 'Build project',
      '/deploy': 'Deploy application',
      '/clear': 'Clear conversation context',
      '/exit': 'Exit MARIA CLI'
    };
    
    this.setupEventHandlers();
  }

  displayLogo() {
    console.clear();
    
    // Simple white ASCII logo
    const logoText = `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                   â•‘
â•‘  â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                                          â•‘
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—                                         â•‘
â•‘  â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘                                         â•‘
â•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘                                         â•‘
â•‘  â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘                                         â•‘
â•‘  â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•šâ•â•  â•šâ•â•                                         â•‘
â•‘                                                                                   â•‘
â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                                              â•‘
â•‘  â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•                                              â•‘
â•‘  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                                                â•‘
â•‘  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•                                                â•‘
â•‘  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                                              â•‘
â•‘   â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•                                              â•‘
â•‘                                                                                   â•‘
â•‘      AI-Powered Development Platform                                             â•‘
â•‘                                                                                   â•‘
â•‘      (c) 2025 Bonginkan Inc.                                                    â•‘
â•‘                                                                                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;
    console.log(chalk.magenta(logoText));
    console.log();
  }

  displayWelcome() {
    console.log(chalk.magenta.bold('Welcome to MARIA CODE Interactive Chat'));
    console.log();
    console.log(chalk.yellow('40+ Slash Commands Available - Type /help to see all'));
    console.log(chalk.yellow('Type anytime to interrupt current processing'));
    console.log();
    console.log(chalk.cyan('You can:'));
    console.log(chalk.white('â€¢ Type naturally for AI assistance'));
    console.log(chalk.white('â€¢ Use slash commands for specific actions'));
    console.log(chalk.white('â€¢ Interrupt anytime with new instructions'));
    console.log(chalk.cyan('â€¢ Examples: /code, /test, /review, /video, /image'));
    console.log();
    
    this.showInputPrompt();
  }

  showInputPrompt() {
    console.log(chalk.white('â”Œ' + 'â”€'.repeat(72) + 'â”'));
    console.log(chalk.white('â”‚') + chalk.gray(' Input:') + ' '.repeat(64) + chalk.white('â”‚'));
    console.log(chalk.white('â””' + 'â”€'.repeat(72) + 'â”˜'));
    this.rl.setPrompt(chalk.cyan('> '));
    this.rl.prompt();
  }

  setupEventHandlers() {
    this.rl.on('line', (input) => {
      this.handleInput(input.trim());
    });

    this.rl.on('close', () => {
      console.log(chalk.gray('\nGoodbye!'));
      process.exit(0);
    });

    // Handle Ctrl+C gracefully
    process.on('SIGINT', () => {
      if (this.isProcessing) {
        this.interruptProcessing();
        console.log(chalk.gray('\nProcessing interrupted. Enter new command:'));
        this.showInputPrompt();
      } else {
        console.log(chalk.gray('\n\nUse /exit to quit MARIA CLI'));
        this.showInputPrompt();
      }
    });
  }

  detectLanguage(text) {
    // Simple language detection based on character patterns
    const japanesePattern = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/;
    const koreanPattern = /[\uAC00-\uD7AF\u1100-\u11FF]/;
    const chinesePattern = /[\u4E00-\u9FFF]/;
    
    if (japanesePattern.test(text)) {
      return 'ja';
    } else if (koreanPattern.test(text)) {
      return 'ko';
    } else if (chinesePattern.test(text) && !japanesePattern.test(text)) {
      return 'zh';
    }
    return 'en';
  }

  async handleInput(input) {
    if (!input) {
      this.showInputPrompt();
      return;
    }

    // If currently processing, add to interrupt queue
    if (this.isProcessing) {
      this.interruptProcessing();
      console.log(chalk.gray('\n[Interrupted - Processing new request]'));
      
      // Determine if it's additional info or override
      const isAdditional = this.isAdditionalInfo(input);
      if (isAdditional) {
        console.log(chalk.gray('[Treating as additional information]'));
      } else {
        console.log(chalk.gray('[Overriding previous request]'));
      }
      
      // Add interrupt context to conversation
      this.conversationContext.push({
        role: 'system',
        content: isAdditional 
          ? 'User provided additional information. Incorporate this with the previous request.'
          : 'User interrupted with new priority request. Focus on this new request instead.'
      });
    }

    // Handle the command
    if (input.startsWith('/')) {
      await this.executeSlashCommand(input);
    } else {
      await this.handleNaturalLanguage(input);
    }
    
    // Show prompt again after handling input (unless processing is ongoing)
    if (!this.isProcessing) {
      this.showInputPrompt();
    }
  }

  isAdditionalInfo(input) {
    // Simple heuristic to determine if input is additional info
    const additionalKeywords = ['also', 'and', 'plus', 'additionally', 'moreover', 
                                'ã•ã‚‰ã«', 'ã¾ãŸ', 'ãã—ã¦', 'è¿½åŠ ã§', 'ãã‚Œã¨'];
    const lowerInput = input.toLowerCase();
    return additionalKeywords.some(keyword => lowerInput.includes(keyword));
  }

  interruptProcessing() {
    if (this.processingTimeout) {
      clearTimeout(this.processingTimeout);
      this.processingTimeout = null;
    }
    this.isProcessing = false;
    this.currentProcessing = null;
  }

  async executeSlashCommand(input) {
    const [command, ...args] = input.split(' ');
    const commandArg = args.join(' ');
    
    switch(command) {
      case '/help':
        this.showHelp();
        break;
      case '/status':
        this.showStatus();
        break;
      case '/clear':
        this.clearContext();
        break;
      case '/config':
        this.showConfig();
        break;
      case '/model':
        await this.showInteractiveModelSelector();
        break;
      case '/init':
        this.initProject();
        break;
      case '/code':
        await this.generateCode(commandArg);
        break;
      case '/review':
        await this.reviewCode();
        break;
      case '/test':
        await this.runTests();
        break;
      case '/build':
        await this.buildProject();
        break;
      case '/deploy':
        await this.deployProject();
        break;
      case '/exit':
        console.log(chalk.gray('Goodbye!'));
        process.exit(0);
      default:
        console.log(chalk.gray(`Unknown command: ${command}`));
        console.log(chalk.gray('Type /help for available commands'));
    }
  }

  async handleNaturalLanguage(input) {
    // Detect language
    this.currentLanguage = this.detectLanguage(input);
    
    // Add to context
    this.conversationContext.push({ role: 'user', content: input });
    
    // Mark as processing
    this.isProcessing = true;
    
    // Show thinking message
    console.log(chalk.gray('\nThinking...'));
    
    // Simulate AI processing with interrupt capability
    this.processingTimeout = setTimeout(() => {
      if (this.isProcessing) {
        // Generate response based on detected language
        const response = this.generateResponse(input);
        console.log(chalk.white(`\n${response}\n`));
        
        // Add response to context
        this.conversationContext.push({ role: 'assistant', content: response });
        
        this.isProcessing = false;
        this.showInputPrompt();
      }
    }, 2000);
  }

  generateResponse(input) {
    const lang = this.currentLanguage;
    
    // Check if there's interrupt context
    const lastSystemMessage = this.conversationContext
      .filter(msg => msg.role === 'system')
      .slice(-1)[0];
    
    let prefix = '';
    if (lastSystemMessage) {
      if (lastSystemMessage.content.includes('additional information')) {
        prefix = lang === 'ja' ? 'è¿½åŠ æƒ…å ±ã‚’è€ƒæ…®ã—ã¦: ' : 'Considering the additional info: ';
      } else if (lastSystemMessage.content.includes('priority request')) {
        prefix = lang === 'ja' ? 'æ–°ã—ã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«åŸºã¥ã„ã¦: ' : 'Based on your new request: ';
      }
    }
    
    if (lang === 'ja') {
      if (input.includes('ã“ã‚“ã«ã¡ã¯')) {
        return prefix + 'ã“ã‚“ã«ã¡ã¯ï¼MARIAã§ã™ã€‚ã©ã®ã‚ˆã†ã«ãŠæ‰‹ä¼ã„ã—ã¾ã—ã‚‡ã†ã‹ï¼Ÿ';
      }
      return prefix + 'æ‰¿çŸ¥ã—ã¾ã—ãŸã€‚ãã®ã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†ã—ã¦ã„ã¾ã™ã€‚';
    } else if (lang === 'ko') {
      return prefix + 'ë„¤, ë„ì™€ë“œë¦¬ê² ìŠµë‹ˆë‹¤.';
    } else if (lang === 'zh') {
      return prefix + 'å¥½çš„ï¼Œæˆ‘æ¥å¸®æ‚¨å¤„ç†ã€‚';
    } else {
      if (input.toLowerCase().includes('hello')) {
        return prefix + 'Hello! I\'m MARIA. How can I help you today?';
      }
      return prefix + 'I understand your request. Let me help you with that.';
    }
  }

  clearContext() {
    this.conversationContext = [];
    console.log(chalk.gray('\nConversation context cleared'));
    console.log(chalk.gray('Starting fresh conversation'));
  }

  showHelp() {
    console.log(chalk.white('\nMARIA CODE - Available Commands'));
    console.log(chalk.gray('â”€'.repeat(40)));
    
    for (const [cmd, desc] of Object.entries(this.commands)) {
      if (cmd !== '...') {
        console.log(`${chalk.white(cmd.padEnd(15))} ${chalk.gray(desc)}`);
      }
    }
    
    console.log(chalk.gray('\n+ 26 more slash commands available'));
    console.log(chalk.gray('\nYou can also type natural language requests'));
    console.log(chalk.white('\nInterrupt Feature:'));
    console.log(chalk.gray('â€¢ Type anytime during processing to interrupt'));
    console.log(chalk.gray('â€¢ New requests override previous ones'));
    console.log(chalk.gray('â€¢ Additional info is automatically detected'));
  }

  showStatus() {
    console.log(chalk.white('\nSystem Status'));
    console.log(chalk.gray('â”€'.repeat(30)));
    console.log(chalk.white('â€¢ Status:'), chalk.gray('Online'));
    console.log(chalk.white('â€¢ Model:'), chalk.gray('GPT-4o'));
    console.log(chalk.white('â€¢ Context:'), chalk.gray(`${this.conversationContext.length} messages`));
    console.log(chalk.white('â€¢ Language:'), chalk.gray(this.currentLanguage.toUpperCase()));
    console.log(chalk.white('â€¢ Processing:'), chalk.gray(this.isProcessing ? 'Active' : 'Idle'));
  }

  showConfig() {
    console.log(chalk.white('\nConfiguration'));
    console.log(chalk.gray('â”€'.repeat(30)));
    console.log(chalk.white('â€¢ Config Path:'), chalk.gray('~/.maria-code.toml'));
    console.log(chalk.white('â€¢ Project Root:'), chalk.gray(process.cwd()));
    console.log(chalk.white('â€¢ Node Version:'), chalk.gray(process.version));
    console.log(chalk.white('â€¢ Interrupt:'), chalk.gray('Enabled'));
  }

  async showInteractiveModelSelector() {
    console.log(chalk.white('\nðŸ¤– Interactive Model Selector'));
    console.log(chalk.gray('â”€'.repeat(35)));
    console.log(chalk.gray('Starting full interactive model selector...'));
    
    try {
      // Import and run the interactive model selector
      const { runInteractiveModelSelector } = await import('./src/commands/model-interactive.js');
      const selectedModel = await runInteractiveModelSelector();
      
      if (selectedModel) {
        console.log(chalk.green(`\nâœ… Model updated to: ${selectedModel}`));
      } else {
        console.log(chalk.gray('\nModel selection cancelled'));
      }
    } catch (error) {
      console.error(chalk.red('Error loading interactive model selector:'), error);
      console.log(chalk.yellow('\nFalling back to simple model list...'));
      this.showModels();
    }
  }

  showModels() {
    console.log(chalk.white('\nAI Models - August 2025'));
    console.log(chalk.gray('â”€'.repeat(30)));
    console.log(chalk.magenta('Cloud Models:'));
    console.log(chalk.white('â€¢ GPT-5'), chalk.gray('(OpenAI) - ðŸ”¥ Latest flagship'));
    console.log(chalk.white('â€¢ GPT-5 mini'), chalk.gray('(OpenAI) - Smaller but powerful'));
    console.log(chalk.white('â€¢ o3'), chalk.gray('(OpenAI) - ðŸ§  Reasoning model'));
    console.log(chalk.white('â€¢ Claude Opus 4.1'), chalk.gray('(Anthropic) - ðŸŽ¯ Latest Claude'));
    console.log(chalk.white('â€¢ Claude 4 Sonnet'), chalk.gray('(Anthropic) - âš¡ Best for coding'));
    console.log(chalk.white('â€¢ Gemini 2.5 Pro'), chalk.gray('(Google) - ðŸ§  Enhanced reasoning, multimodal'));
    console.log(chalk.white('â€¢ Gemini 2.5 Flash'), chalk.gray('(Google) - âš¡ Adaptive thinking, cost-effective'));
    console.log(chalk.white('â€¢ Gemini 2.5 Flash-Lite'), chalk.gray('(Google) - ðŸš€ Most cost-effective, high throughput'));
    console.log(chalk.white('â€¢ Grok 4'), chalk.gray('(xAI) - ðŸ¤– Real-time web'));
    console.log(chalk.white('â€¢ Llama 4 405B'), chalk.gray('(Meta) - ðŸ¦™ GPT-5 competitor'));
    console.log(chalk.white('â€¢ Mistral Large 3'), chalk.gray('(Mistral) - ðŸ‡«ðŸ‡· European AI'));
    console.log(chalk.gray('\n' + 'â”€'.repeat(30)));
    console.log(chalk.magenta('Local Models (LM Studio):'));
    console.log(chalk.white('â€¢ Qwen 3 MoE 30B'), chalk.gray('- ðŸ† Q4_K_M, 18.56GB'));
    console.log(chalk.white('â€¢ GPT-OSS 120B'), chalk.gray('- ðŸ§  MXFP4, 63.39GB'));
    console.log(chalk.white('â€¢ GPT-OSS 20B'), chalk.gray('- ðŸš€ MXFP4, 12.11GB'));
    console.log(chalk.white('â€¢ Mistral 7B v0.3'), chalk.gray('- âš¡ Q4_K_M, 4.37GB'));
  }

  async initProject() {
    this.isProcessing = true;
    console.log(chalk.white('\nGenerating MARIA.md - AI Development Design Document...'));
    console.log(chalk.gray('â”€'.repeat(50)));
    
    console.log(chalk.gray('Analyzing codebase...'));
    console.log(chalk.gray('â€¢ Scanning file structure'));
    console.log(chalk.gray('â€¢ Analyzing dependencies'));
    console.log(chalk.gray('â€¢ Detecting patterns and architecture'));
    
    this.processingTimeout = setTimeout(() => {
      if (this.isProcessing) {
        console.log(chalk.gray('\nAI Processing...'));
        console.log(chalk.gray('â€¢ Understanding project purpose'));
        console.log(chalk.gray('â€¢ Extracting technical specifications'));
        console.log(chalk.gray('â€¢ Generating SOW (Statement of Work)'));
        console.log(chalk.gray('â€¢ Creating development guidelines'));
        
        console.log(chalk.white('\nMARIA.md Generated Successfully'));
        console.log(chalk.gray('\nMARIA.md is now available in your project root'));
        this.isProcessing = false;
      }
    }, 3000);
  }

  async generateCode(prompt) {
    if (!prompt) {
      console.log(chalk.gray('Please provide a code generation prompt'));
      console.log(chalk.gray('Example: /code Create a REST API for user authentication'));
      return;
    }
    
    this.isProcessing = true;
    console.log(chalk.white('\nAI Code Generation'));
    console.log(chalk.gray('â”€'.repeat(25)));
    console.log(chalk.white('Prompt:'), chalk.gray(prompt));
    console.log(chalk.gray('\nThinking...'));
    
    this.processingTimeout = setTimeout(() => {
      if (this.isProcessing) {
        console.log(chalk.white('\nGenerated code saved to: src/generated/'));
        this.isProcessing = false;
      }
    }, 3000);
  }

  async reviewCode() {
    this.isProcessing = true;
    console.log(chalk.white('\nCode Review'));
    console.log(chalk.gray('â”€'.repeat(20)));
    console.log(chalk.gray('Analyzing current changes...'));
    
    this.processingTimeout = setTimeout(() => {
      if (this.isProcessing) {
        console.log(chalk.gray('â€¢ Security vulnerabilities: None'));
        console.log(chalk.gray('â€¢ Code quality issues: 2 warnings'));
        console.log(chalk.gray('â€¢ Performance concerns: None'));
        this.isProcessing = false;
      }
    }, 2000);
  }

  async runTests() {
    this.isProcessing = true;
    console.log(chalk.white('\nRunning Tests'));
    console.log(chalk.gray('â”€'.repeat(20)));
    
    this.processingTimeout = setTimeout(() => {
      if (this.isProcessing) {
        console.log(chalk.gray('â€¢ Unit tests: 45 passed'));
        console.log(chalk.gray('â€¢ Integration tests: 12 passed'));
        console.log(chalk.gray('â€¢ Coverage: 87%'));
        this.isProcessing = false;
      }
    }, 2500);
  }

  async buildProject() {
    this.isProcessing = true;
    console.log(chalk.white('\nBuilding Project'));
    console.log(chalk.gray('â”€'.repeat(20)));
    console.log(chalk.gray('â€¢ Compiling TypeScript...'));
    
    this.processingTimeout = setTimeout(() => {
      if (this.isProcessing) {
        console.log(chalk.gray('â€¢ Bundling assets...'));
        console.log(chalk.white('Build completed successfully'));
        this.isProcessing = false;
      }
    }, 2000);
  }

  async deployProject() {
    this.isProcessing = true;
    console.log(chalk.white('\nDeploying Application'));
    console.log(chalk.gray('â”€'.repeat(25)));
    console.log(chalk.gray('â€¢ Building Docker image...'));
    
    this.processingTimeout = setTimeout(() => {
      if (this.isProcessing) {
        console.log(chalk.gray('â€¢ Pushing to registry...'));
        console.log(chalk.gray('â€¢ Deploying to Cloud Run...'));
        console.log(chalk.white('Deployment successful'));
        this.isProcessing = false;
        this.showInputPrompt();
      }
    }, 3500);
  }

  async start() {
    this.displayLogo();
    this.displayWelcome();
  }
}

// Start the CLI
const cli = new MariaCLI();
cli.start();